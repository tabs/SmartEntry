C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE UTILSFUNCTION
OBJECT MODULE PLACED IN .\Objects\UtilsFunction.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE UtilsFunction.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X2000) DEBUG O
                    -BJECTEXTEND PRINT(.\Listings\UtilsFunction.lst) TABS(2) OBJECT(.\Objects\UtilsFunction.obj)

line level    source

   1          #include "flashfunction.h"
   2          #include "LD9900MT.h"
   3          #include "DS1302.h"
   4          #include "SC50X0B.h"
   5          #include "init.h"
   6          #define BuzzerTimeNormal  0x01            //´¥·¢Ò»´Î·äÃùÆ÷ÏìµÄÊ±¼ä£¨Õı³£100ms£©
   7          #define BuzzerTimeLong 0x02               //´¥·¢Ò»´Î·äÃùÆ÷ÏìµÄÊ±¼ä£¨À­³¤3000ms£©
   8          #define BuzzerTimeShort 0x03              //¼±´Ù·äÃùÆ÷£¨20ms£©
   9          #define FE_MESSTYPEADDR 11 /*ÏûÏ¢ÀàĞÍ×Ö½ÚÔÚÖ¡ÖĞµÄÆğÊ¼Î»ÖÃ*/
  10          #define FE_DATAADDR 13 /*Êı¾İ×Ö½ÚÔÚÖ¡ÖĞµÄÆğÊ¼Î»ÖÃ*/
  11          #define FE_CODENUM 10 //Ö¡ĞòºÅ×Ö½ÚÔÚÖ¡ÖĞµÄÆğÊ¼Î»ÖÃ
  12          #define FE_LENGTH 2 //¶¨ÒåÊı¾İ³¤¶ÈÔÚÖ¡ÖĞµÄÎ»ÖÃ
  13          #define SYSTEM_ID 4 //¶¨Òå±¾»ú±àºÅÔÚÖ¡ÖĞµÄÎ»ÖÃ
  14          #define FindCard_TimerCounterMAX 50 /*Ã¿¸ô0.5s¼ì²âÒ»´ÎÉí·İÖ¤ÊÇ·ñ´æÔÚ*/
  15          #define ShieldCMD_OpenOrCloseTime 300 /*±¾µØ¿ªÕ¢ºóÆÁ±Î·şÎñÆ÷¿ªÕ¢Ê±¼ä3S*/
  16          #define ResetU980Time 100*300     /*¶şÎ¬Âë¶¨Ê±ÖØÆô300S*/
  17          #define SYSTEM_ID 4 //¶¨Òå±¾»ú±àºÅÔÚÖ¡ÖĞµÄÎ»ÖÃ
  18          #define SysCordAppUpdataAddrFlag 0x7E00
  19          #define SysCordAppSaveStartTempAddr 0x8000 /*³ÌĞòÓ¦ÓÃÇøÔİ´æµÄÆğÊ¼µØÖ·*/
  20          #define STATE_NOCARD 0
  21          #define STATE_SELECTCARD 1
  22          #define STATE_READCARD 2
  23          bit DoorTrigger;
  24          bit ResetU980Trigger;
  25          bit ShieldOpenOrClose;
  26          bit OpenOrClose;
  27          bit Flag_ErWeiMaReceiveStart;
  28          unsigned int DoorOpenTime = 10;
  29          unsigned int u8RevcLen = 0;
  30          unsigned char EWMBuffer1[23] ={0x00};
  31          unsigned char EWMBuffer[12] ={0x00};
  32          unsigned char Com2Buf=0;
  33          
  34          unsigned int EWMCounter = 0;
  35          unsigned char BluetoothRecBuffer[30] = {0x00};//À¶ÑÀ½ÓÊÕÊı¾İ»º´æ
  36          unsigned int BTCounter = 0;//À¶ÑÀ½ÓÊÕÊı×é¼ÆÊıÆ÷
  37          unsigned char FingerDataBuffer[600] = {0x00}  ;
  38          unsigned int DoorCounter = 0;
  39          unsigned int ResetU980Counter = 0;
  40          unsigned int ShieldCMD_OpenOrCloseCounter = 0;
  41          unsigned char System_ID[6]={0x03,0x71,0x00,0x01,0x00,0x01};
  42          const unsigned char code AppVersionNum[4] = {0x20,0x16,0x06,0x14};/*Õ¢»ú³ÌĞò°æ±¾±àºÅV2016.5.26*/
  43          const unsigned char code FE_START[2]={0x55,0xaa};
  44          const unsigned char code FE_START_ACK[2]={0xaa,0x55};//»Ø¸´ÉÏÎ»»úµÄÖ¡Í·
  45          const unsigned char code CMD_Heartbeat[2]={0x00,0x01};/*ĞÄÌø°üÃüÁî*/
  46          //const unsigned char code CMD_ServerAck[2]={0x01,0x01};/*ºÍ·şÎñÆ÷Í¨ĞÅ³¬Ê±ÖØÆôWIFI*/
  47          const unsigned char code CMD_ReStart[2]={0x00,0x02};/*ÖØÆôÃüÁî*/
  48          const unsigned char code CMD_UpdateSystem[2]={0x00,0x06};/*ÉÏ°åÉı¼¶ÃüÁî*/
  49          const unsigned char code CMD_OpenOrClose[2]={0x00,0x03};/*Ç¿ÖÆ¿ª¹ØÕ¢*/
  50          const unsigned char code CMD_SearchUerID[2]={0x80,0x01};/*ËÑË÷ÓÎ¿ÍÉí·İÖ¤ĞÅÏ¢*/
  51          const unsigned char code CMD_SearchErWerMa[2]={0x70,0x01};/*ËÑË÷ÓÎ¿Í¶şÎ¬ÂëĞÅÏ¢*/
  52          const unsigned char code CMD_DownLoadUerID[2]={0x30,0x01};/*ÏÂÔØÉí·İÖ¤ĞÅÏ¢*/
  53          const unsigned char code CMD_UploadUerID[2]={0x00,0x19};/*Á÷Ë®¹¦ÄÜÉÏ´«Éí·İÖ¤*/
  54          const unsigned char code CMD_DownLoadErWerMa[2]={0x40,0x01};/*ÏÂÔØ¶şÎ¬ÂëĞÅÏ¢*/
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 2   

  55          const unsigned char code CMD_DownLoadFingerData[2]={0x50,0x01};/*ÏÂÔØÖ¸ÎÆĞÅÏ¢*/
  56          const unsigned char code CMD_UploadErWeiMa[2]={0x00,0x29};/*Á÷Ë®¹¦ÄÜÉÏ´«¶şÎ¬Âë*/
  57          const unsigned char code CMD_FingerUploadStreamInfo[2]={0x00,0x39};/*Á÷Ë®¹¦ÄÜÉÏ´«Ö¸ÎÆ¶ÔÓ¦µÄID*/
  58          const unsigned char code CMD_DeleteFingerID[2]={0x50,0x02};/*É¾³ıµ¥ÌõÖ¸ÎÆĞÅÏ¢*/
  59          const unsigned char code CMD_DeleteErWeiMa[2]={0x40,0x02};/*É¾³ıµ¥Ìõ¶şÎ¬ÂëĞÅÏ¢*/
  60          const unsigned char code CMD_DeleteID[2]={0x30,0x02};/*É¾³ıµ¥ÌõÉí·İÖ¤ĞÅÏ¢*/
  61          const unsigned char code CMD_DeleteAllErWeiMa[2]={0x40,0x03};/*É¾³ıËùÓĞ¶şÎ¬ÂëĞÅÏ¢*/
  62          const unsigned char code CMD_DeleteAllID[2]={0x30,0x03};/*É¾³ıËùÓĞÉí·İÖ¤ĞÅÏ¢*/
  63          const unsigned char code CMD_DeleteAllUserID[2]={0x88,0x88};/*É¾³ıËùÓĞÓÃ»§IDĞÅÏ¢*/
  64          const unsigned char code CMD_FirstRecordFinger[2]={0x31, 0x03};/*µÚÒ»´ÎÂ¼È¡Ö¸ÎÆ*/
  65          const unsigned char code CMD_SecondRecordFinger[2]={0x32, 0x03};/*µÚ¶ş´ÎÂ¼È¡Ö¸ÎÆ*/
  66          const unsigned char code CMD_EmptyFingerRecord[2]={0x50, 0x03};/*Çå¿ÕÖ¸ÎÆ¿â*/
  67          const unsigned char code CMD_AskAppVersionNum_Top[2]={0x60,0x01};/*²éÑ¯Õ¢»úÉÏ°åÈí¼ş°æ±¾ºÅ*/
  68          const unsigned char code CMD_AskAppVersionNum_Bottom[2]={0x60,0x02};/*²éÑ¯Õ¢»úÏÂ°åÈí¼ş°æ±¾ºÅ*/
  69          const unsigned char code CMD_WifiSerialConfigMode[2]={0xf8,0x01};/*½øÈëWIFI´®¿ÚÅäÖÃÄ£Ê½ÃüÁî*/
  70          const unsigned char code CMD_Buzzer[2]={0xff,0xff};/*·äÃùÆ÷ÃüÁî*/
  71          const unsigned char code CMD_DoorTrigger[2]={0xfe,0xfe};/*ÄÚ²¿¿ªÕ¢ÃüÁî*/
  72          const unsigned char code CMD_SetSystemId[2]={0xff,0x01};/*Õ¢»úIDÉèÖÃÃüÁî*/
  73          const unsigned char code CMD_nReloadWifi[2]={0xff,0x02};/*Õ¢»úÖØÖÃWIFIÃüÁî*/
  74          const unsigned char code CMD_SetDoorOpenTime[2]={0xff,0x03};/*Õ¢»ú¿ªÃÅÊ±¼äÉèÖÃÃüÁî*/
  75          const unsigned char code CMD_DeleteSystem_SetPara[2]={0xff,0x04};/*É¾³ıÏµÍ³²ÎÊıÉèÖÃ*/
  76          const unsigned char code FIND_CARD[10]={0xaa, 0xaa, 0xaa, 0x96, 0x69, 0x00, 0x03, 0x20, 0x01, 0x22};
  77          const unsigned char code SELECT_CARD[10]={0xaa, 0xaa, 0xaa, 0x96, 0x69, 0x00, 0x03, 0x20, 0x02, 0x21};
  78          const unsigned char code READ_CARD[10]={0xaa, 0xaa, 0xaa, 0x96, 0x69, 0x00, 0x03, 0x30, 0x01, 0x32};
  79          
  80          //0x1000-0x7E00  ?C_C51STARTUP(1000H)
  81          
  82          //Éí·İÖ¤´¢´æ»®·Ö´¢´æµØÖ·±í,Ã¿ÌõĞÅÏ¢Õ¼ÓÃ20×Ö½Ú
  83          //Éí·İÖ¤´¢´æ¸ù¾İÉí·İÖ¤ºÅ×îºóÒ»Î»Ğ£ÑéÂë»®·ÖÎª11¸öÇøÓò£¬Ã¿¸öÇøÓò128KB Ã¿ÌõÉí·İÖ¤ĞÅÏ¢¼ÓÉÏÊ±¼ä20¸ö×Ö½Ú
  84          //Ã¿¸öÇøÓò¹²¿ÉÒÔ´¢´æ6553-3ÌõĞÅÏ¢£¬ÕâÀïÇ°3*20=60×Ö½ÚÓÃÀ´´¢´æ¸½¼ÓµÄĞÅÏ¢£¬±ÈÈçµ±Ç°ÇøÓòµÄ´¢´æÊıÁ¿¡£Ã¿¸öÇøÓò128
             -KB¹²Õ¼ÓÃ1408KB¿Õ¼ä
  85          const unsigned long int code Id_StoreAddrTable[11][2] = {{0x000000,0x1ffff},{0x20000,0x3ffff},{0x40000,0x5
             -ffff},{0x60000,0x7ffff},
  86          {0x80000,0x9ffff},{0xa0000,0xbffff},{0xc0000,0xdffff},{0xe0000,0xfffff},{0x100000,0x11ffff},{0x120000,0x13
             -ffff},{0x140000,0x15ffff}};
  87          //¶şÎ¬Âë´¢´æ»®·Ö´¢´æµØÖ·±í£¬Ã¿ÌõĞÅÏ¢Õ¼ÓÃ10×Ö½Ú
  88          //¶şÎ¬Âë´¢´æ¸ù¾İÊÖ»úºÅÀÛ¼ÓµÃµ½Ò»¸öintĞÍÊı¾İÈ¡µÍ4Î»×÷Îª·ÖÀàÒÀ¾İ0x00-0x0f(16¸ö·ÖÀà)
  89          //Ã¿¸öÇøÓò¹²¿ÉÒÔ´¢´æ6553-3ÌõĞÅÏ¢£¬ÕâÀïÇ°3*10=30×Ö½ÚÓÃÀ´´¢´æ¸½¼ÓµÄĞÅÏ¢£¬±ÈÈçµ±Ç°ÇøÓòµÄ´¢´æÊıÁ¿¡£Ã¿¸öÇøÓò64K
             -B¹²Õ¼ÓÃ1024KB¿Õ¼ä
  90          const unsigned long int code ErWeiMa_AddrTable[16][2] = {{0x160000,0x16ffff},{0x170000,0x17ffff},{0x180000
             -,0x18ffff},{0x190000,0x19ffff},
  91          {0x1a0000,0x1affff},{0x1b0000,0x1bffff},{0x1c0000,0x1cffff},{0x1d0000,0x1dffff},{0x1e0000,0x1effff},{0x1f0
             -000,0x1fffff},{0x200000,0x20ffff},
  92          {0x210000,0x21ffff},{0x220000,0x22ffff},{0x230000,0x23ffff},{0x240000,0x24ffff},{0x250000,0x25ffff}};
  93          //ÓÃ»§id-Ö¸ÎÆ±àºÅµÄ´¢´æºÍ¶şÎ¬ÂëµÄÏàÍ¬
  94          const unsigned long int code FingerId_AddrTable[16][2] = {{0x260000,0x26ffff},{0x270000,0x27ffff},{0x28000
             -0,0x28ffff},{0x290000,0x29ffff},
  95          {0x2a0000,0x2affff},{0x2b0000,0x2bffff},{0x2c0000,0x2cffff},{0x2d0000,0x2dffff},{0x2e0000,0x2effff},{0x2f0
             -000,0x2fffff},{0x300000,0x30ffff},
  96          {0x310000,0x31ffff},{0x320000,0x32ffff},{0x330000,0x33ffff},{0x340000,0x34ffff},{0x350000,0x35ffff}};
  97          const unsigned char code EWMBuffer_Mima[11]={0xDB,0xCA,0xFE,0x63,0x78,0x12,0x43,0x67,0x35,0x23,0x98};
  98          unsigned char UART_Fe_Seq  = 0;           //Ö¡ĞòºÅ
  99          unsigned char CommonDataBuffer[600]={0};//Êı¾İ»º´æÊı×é
 100          unsigned char FingerPrcBuffer[600]={0};//Ö¸ÎÆÊı¾İÔİ´æ´¦ÀíÊı×é
 101          unsigned int Exint0Counter = 0;           //Íâ²¿ÖĞ¶Ï0½ÓÊÜÊı¾İ¼ÆÊıÆ÷
 102          unsigned char Exint0DataBuffer[600] = {0};
 103          unsigned char Uart4FindCartACK[200] = {0};//Éí·İÖ¤ĞÅÏ¢»º´æÊı×é
 104          unsigned int Uart4ACKCounter = 0;//Éí·İÖ¤Êı¾İ½ÓÊÕ¼ÆÊıÆ÷
 105          unsigned char UserCardReadState=0; 
 106          unsigned char Flag_FindCard_500msOver=0;
 107          unsigned int FindCard_TimerCounter=0;
 108          
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 3   

 109          
 110          unsigned char SetTime[7]={30,52,22,27,03,04,16};//Ãë·ÖÊ±ÈÕÔÂÖÜÄê10-08-15 23:59:50   7´ú±íÖÜÈÕ
 111          unsigned char TimeReadBuffer[7] = {0x00};
 112          void Exint0_DATA_deal(void);
 113          void Uart2_DATA_deal(void);
 114          void Uart3_DATA_deal(void);
 115          void Uart4_DATA_deal(void);
 116          void Poll_Finger_Module(void);
 117          extern void USART1_Send(unsigned char *dat,unsigned int len);
 118          extern void USART4_Send(unsigned char *dat,unsigned int len);
 119          void Arraycat(unsigned char *Data_Dest,unsigned char *Data_Src,unsigned int DestDataNum,unsigned int SrcDa
             -taNum);
 120          unsigned int Fe_data_Organize(unsigned char CMD[],unsigned char Data[],unsigned int DataNum,bit OrgType);
 121          char Muti_Read_Byte(void);
 122          void Muti_Send_Byte(unsigned char *Data,unsigned int len);
 123          void Reply_State(unsigned char CMD[],unsigned char State);
 124          void Buzzer_Beep(unsigned char TimeFlag);
 125          UCHAR FLASH_ByteRead(FLADDR addr);
 126          void FLASH_ByteWrite(FLADDR addr, UCHAR dat);
 127          void FLASH_PageErase(FLADDR addr);
 128          UCHAR sequential_write_flash_in_one_sector(UINT begin_addr, UINT counter, UCHAR *array);
 129          UCHAR Delete_IdOrErWeiMa_Info(UCHAR *IdData,UCHAR SecletFlag);
 130          unsigned long int Search_IdOrErWeiMa_Info(UCHAR *Data,UCHAR SecletFlag);
 131          unsigned char Store_IdOrErWeiMa_Data(unsigned char *Data,UCHAR SecletFlag);
 132          unsigned long int  SearchFingerStoreNumber(unsigned char FingerStoreNumber[]);
 133          unsigned char Bytencmp(unsigned char *src,unsigned char *dest,unsigned int len);
 134          void btlder(void);
 135          extern void Delay_ms(UINT ms);
 136          extern void Delay_us(UINT ms);
 137          void main(void)
 138            { UINT i = 0;
 139   1      //   for(i=0;i<10;i++)
 140   1      //    { Com2Buf= 0x65;
 141   1      //   if((Flag_ErWeiMaReceiveStart==0)&&(Com2Buf==0x65))
 142   1      //    {EWMCounter=0;Flag_ErWeiMaReceiveStart=1;}
 143   1      //   if(Flag_ErWeiMaReceiveStart==1)
 144   1      //    {if(EWMCounter<22)  EWMBuffer1[EWMCounter++] = Com2Buf;
 145   1      //     if(EWMCounter>22) {EWMCounter=0;Flag_ErWeiMaReceiveStart=0; }
 146   1      //    }
 147   1      //    }  
 148   1        IO_Init();
 149   1        init_Uart();
 150   1        Timer0Init();
 151   1        INT_Init();
 152   1        System_SetParaInit();
 153   1        EA=1;
 154   1        Delay_ms(500);
 155   1        Muti_Send_Byte(CommonDataBuffer,Fe_data_Organize(CMD_SetSystemId,System_ID,6,1)); 
 156   1        while(1)
 157   1        {if(Exint0Counter != 0)
 158   2          {Exint0_DATA_deal();}
 159   2         if(EWMCounter >= 21)
 160   2          {Uart2_DATA_deal();}
 161   2         if(BTCounter >= 1)
 162   2          {Uart3_DATA_deal();}
 163   2         if(ResetU980Trigger)
 164   2          {Reset_U980 = 0;
 165   3           Delay_ms(1000);
 166   3           Reset_U980 = 1;
 167   3           ResetU980Trigger=0;
 168   3          }
 169   2          Uart4_DATA_deal();
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 4   

 170   2          Poll_Finger_Module();
 171   2         }  
 172   1      }
 173          
 174          /****************************************************/
 175          /* ¶¨Ê±Æ÷0ÖĞ¶ÏÈë¿Úº¯Êı                      */
 176          /* ³ÌĞò¹¦ÄÜ£º¶¨Ê±Æ÷0ÖĞ¶Ï´¦Àíº¯Êı£¬±ØĞëĞ´³ÉÕâÑùµÄĞÎÊ½*/
 177          /* Èë¿Ú²ÎÊı:ÎŞ                    */
 178          /* ³ö¿Ú²ÎÊı:ÎŞ                    */
 179          /****************************************************/
 180          void Timer0_intrupt_function(void) interrupt 1 using 1
 181          { 
 182   1        /*¿ªÃÅ¶¯×÷*/
 183   1        if(DoorTrigger==1)
 184   1        {Door1_Ctl_0=0;
 185   2         Door1_Ctl_1=0;
 186   2         DoorCounter++;
 187   2         if(DoorCounter>DoorOpenTime)
 188   2          {DoorTrigger=0;DoorCounter=0;Door1_Ctl_0=1;Door1_Ctl_1=1;
 189   3        while(1 == SC50x0B_Busy());
 190   3        SC50x0B_Out(DOOROPEN);
 191   3          }
 192   2         }
 193   1        //Éí·İÖ¤
 194   1        if((Flag_FindCard_500msOver==0)&&(UserCardReadState==STATE_NOCARD))
 195   1         {FindCard_TimerCounter++;
 196   2          if(FindCard_TimerCounter>FindCard_TimerCounterMAX)
 197   2           {Flag_FindCard_500msOver=1;FindCard_TimerCounter=0;}}
 198   1       //ÖØÖÃ¶şÎ¬ÂëÄ£¿é
 199   1       if(ResetU980Trigger == 0)
 200   1       {
 201   2         ResetU980Counter++;
 202   2         if(ResetU980Counter>ResetU980Time)
 203   2         {
 204   3           ResetU980Trigger =1;
 205   3           ResetU980Counter = 0;
 206   3         }
 207   2       }
 208   1      //ÆÁ±ÎÖ¸ÎÆÑéÖ¤ºóµÄ·şÎñ¶Ë¿ªÕ¢
 209   1       if(ShieldOpenOrClose == 1)
 210   1         {
 211   2           ShieldCMD_OpenOrCloseCounter++;
 212   2           if(ShieldCMD_OpenOrCloseCounter>ShieldCMD_OpenOrCloseTime)
 213   2           {
 214   3             ShieldCMD_OpenOrCloseCounter=0;
 215   3             ShieldOpenOrClose=0;
 216   3           }
 217   2         }
 218   1       
 219   1      }
 220          
 221          void com1_isr(void) interrupt 4 using 1
 222          { 
 223   1        unsigned char dat;
 224   1      
 225   1      if(RI)
 226   1      { 
 227   2        dat = SBUF;
 228   2        //SBUF=dat;while(!(SCON&0X02));SCON &=~0X02;
 229   2          if(u8RevcLen<600)
 230   2            {
 231   3            FingerDataBuffer[u8RevcLen]=dat;
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 5   

 232   3            u8RevcLen++;
 233   3            }
 234   2          else
 235   2            {
 236   3            u8RevcLen=0;
 237   3            }
 238   2          RI = 0;
 239   2        }
 240   1      }
 241          
 242          void com2_isr(void) interrupt 8 using 1
 243          { if(S2CON&0x01)  /*½ÓÊÕ*/
 244   1         { S2CON &=~0x01;
 245   2           Com2Buf= S2BUF;
 246   2         if((Flag_ErWeiMaReceiveStart==0)&&(Com2Buf==0x65))
 247   2          {EWMCounter=0;Flag_ErWeiMaReceiveStart=1;}
 248   2         if(Flag_ErWeiMaReceiveStart==1)
 249   2          {if(EWMCounter<22)  EWMBuffer1[EWMCounter++] = Com2Buf;
 250   3           if(EWMCounter>22) {EWMCounter=0;Flag_ErWeiMaReceiveStart=0; }
 251   3          }  
 252   2          } 
 253   1      }
 254          
 255          void com3_isr(void) interrupt 17 using 1
 256          {
 257   1          unsigned char dat = 0;
 258   1        if(S3CON&0x01)  /*½ÓÊÕ*/
 259   1      {
 260   2        dat = S3BUF;
 261   2        S3CON &=~0x01;
 262   2      if(BTCounter<30)
 263   2        BluetoothRecBuffer[BTCounter++] = dat;
 264   2      if(BTCounter>30) {BTCounter=0;}
 265   2      }                  
 266   1      
 267   1      }
 268          
 269          void com4_isr(void) interrupt 18 using 1
 270          {
 271   1          unsigned char dat;
 272   1      if(S4CON & 0x01)  /*½ÓÊÕ*/
 273   1      {
 274   2        dat  = S4BUF;
 275   2      //  Uart4ACKCounter++;
 276   2        S4CON &=~0x01;
 277   2        //(UserCardReadState == STATE_NOCARD)||(UserCardReadState == STATE_SELECTCARD)&& 
 278   2        if(Uart4ACKCounter<200)
 279   2        Uart4FindCartACK[Uart4ACKCounter++] = dat;
 280   2        if(Uart4ACKCounter>200)  {Uart4ACKCounter=0;}
 281   2      
 282   2      }
 283   1      }
 284          
 285          void Exint0() interrupt 0       //INT0ÖĞ¶ÏÈë¿Ú
 286          {
 287   1        Exint0DataBuffer[Exint0Counter++] = Muti_Read_Byte();
 288   1      }
 289          
 290          void Exint0_DATA_deal(void){
 291   1      unsigned int i = 0,j = 0,DataLength = 0,FingerStoreNumber = 0;
 292   1      unsigned int LastUpdatePacFlag = 0,FE_CS = 0;
 293   1      unsigned long int DeleAddr = 0;
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 6   

 294   1      // unsigned int StoreNum = 0;
 295   1      static bit FirstState = 0,SecondState = 0;
 296   1      unsigned char flag = 0, CS = 0,TimeOverCounter = 0,StoreNumBuffer[2] = {0};
 297   1      unsigned char FingerStoreNumberBuffer[2]={0};
 298   1        Delay_ms(100);
 299   1      //    for(i=0;i<Exint0Counter;i++){
 300   1      //SBUF = Exint0DataBuffer[i];while(!(SCON&0x02));SCON &=~0x02;
 301   1      //}
 302   1      //  SBUF = 0xf7;while(!(SCON&0x02));SCON &=~0x02;
 303   1        if((Exint0DataBuffer[0] == FE_START[0])&&(Exint0DataBuffer[1] == FE_START[1])){
 304   2          DataLength = Exint0DataBuffer[FE_LENGTH]*0x100+Exint0DataBuffer[FE_LENGTH+1];
 305   2          FE_CS=DataLength+FE_DATAADDR;/*Ö¸ÏòĞ£ÑéÂëµÄÎ»ÖÃ*/
 306   2          for(i=0;i<FE_DATAADDR+DataLength;i++)//¼ÆËãĞ£ÑéÂë
 307   2          CS+=Exint0DataBuffer[i];
 308   2          
 309   2            for(i=0,j=0;i<6,j<6;i++,j++){
 310   3            if(System_ID[j] == Exint0DataBuffer[SYSTEM_ID+i])                             //ÅĞ¶ÏÊÇ·ñÊÇ±¾»ú±àºÅ
 311   3              flag++;
 312   3        }
 313   2      //    for(i=0;i<Exint0Counter;i++){
 314   2      //SBUF = Exint0DataBuffer[i];while(!(SCON&0x02));SCON &=~0x02;
 315   2      //}
 316   2        if(CS == Exint0DataBuffer[FE_CS] && flag == 0x06){//Ğ£ÑéÂëÕıÈ·
 317   3          UART_Fe_Seq = Exint0DataBuffer[FE_CODENUM];               //¼ÍÂ¼Ö¡ĞòºÅ
 318   3      //    for(i=0;i<Exint0Counter;i++){
 319   3      //SBUF = Exint0DataBuffer[i];while(!(SCON&0x02));SCON &=~0x02;
 320   3      //}
 321   3          //Ç¿ÖÆ¿ª¹ØÕ¢
 322   3            if((CMD_OpenOrClose[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_OpenOrClose[1] ==  Exint0DataBuff
             -er[FE_MESSTYPEADDR+1]) && !ShieldOpenOrClose)
 323   3            { 
 324   4              DoorTrigger = 1;
 325   4              Reply_State(CMD_OpenOrClose,1);
 326   4              Buzzer_Beep(BuzzerTimeNormal);
 327   4            }//½øÈëWIFI´®¿ÚÅäÖÃÄ£Ê½
 328   3            if((CMD_WifiSerialConfigMode[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_WifiSerialConfigMode[1] 
             -==  Exint0DataBuffer[FE_MESSTYPEADDR+1]))
 329   3            {
 330   4              Muti_Send_Byte(Exint0DataBuffer,Exint0Counter);
 331   4            }//ĞÄÌø°ü»Ø¸´
 332   3            if((CMD_Heartbeat[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_Heartbeat[1] ==  Exint0DataBuffer[F
             -E_MESSTYPEADDR+1]))
 333   3            {
 334   4              Muti_Send_Byte(Exint0DataBuffer,Exint0Counter);
 335   4            }     
 336   3            //ÖØÆô
 337   3            if((CMD_ReStart[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_ReStart[1] ==  Exint0DataBuffer[FE_ME
             -SSTYPEADDR+1]))
 338   3            { 
 339   4              Muti_Send_Byte(CommonDataBuffer,Fe_data_Organize(CMD_ReStart,&flag,1,1));
 340   4              Delay_ms(1000);
 341   4              Buzzer_Beep(BuzzerTimeNormal);
 342   4              IAP_CONTR = 0x20;
 343   4            }
 344   3            //ÄÚ²¿¿ªÕ¢
 345   3            if((CMD_DoorTrigger[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_DoorTrigger[1] ==  Exint0DataBuff
             -er[FE_MESSTYPEADDR+1]))
 346   3            { 
 347   4              DoorTrigger = 1;
 348   4            }//²éÑ¯ÉÏ°åÈí¼ş°æ±¾ºÅ
 349   3            if((CMD_AskAppVersionNum_Top[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_AskAppVersionNum_Top[1] 
             -==  Exint0DataBuffer[FE_MESSTYPEADDR+1])){
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 7   

 350   4              Muti_Send_Byte(CommonDataBuffer,Fe_data_Organize(CMD_AskAppVersionNum_Top,AppVersionNum,4,0));
 351   4            }//²éÑ¯ÏÂ°åÈí¼ş°æ±¾ºÅ
 352   3            if((CMD_AskAppVersionNum_Bottom[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_AskAppVersionNum_Bott
             -om[1] ==  Exint0DataBuffer[FE_MESSTYPEADDR+1])){
 353   4              Muti_Send_Byte(Exint0DataBuffer,Exint0Counter);
 354   4            }     
 355   3            //ÉèÖÃÕ¢»úIDºÅ
 356   3            if((CMD_SetSystemId[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_SetSystemId[1] ==  Exint0DataBuff
             -er[FE_MESSTYPEADDR+1]))
 357   3            { 
 358   4              FLASH_W25Q64_Update (System_SetParaAddr, &Exint0DataBuffer[FE_DATAADDR], sizeof(System_ID));//¸üĞÂÏµÍ³
             -IDĞÅÏ¢
 359   4              Muti_Send_Byte(CommonDataBuffer,Fe_data_Organize(CMD_SetSystemId,&Exint0DataBuffer[FE_DATAADDR],6,1));
 360   4              Delay_ms(1000);
 361   4              Muti_Send_Byte(CommonDataBuffer,Fe_data_Organize(CMD_ReStart,&flag,1,1));//ÖØÆô
 362   4              IAP_CONTR = 0x20;
 363   4            }//Èí¼şÉı¼¶
 364   3            if((CMD_UpdateSystem[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_UpdateSystem[1] ==  Exint0DataBu
             -ffer[FE_MESSTYPEADDR+1]))
 365   3            { 
 366   4                if(Exint0DataBuffer[FE_DATAADDR] == 0x00){
 367   5                  if(Exint0DataBuffer[FE_DATAADDR+4]==Exint0DataBuffer[FE_DATAADDR+6]){//×îºóÒ»¸öÉı¼¶°ü
 368   6                    if(sequential_write_flash_in_one_sector(SysCordAppSaveStartTempAddr+(Exint0DataBuffer[FE_DATAADDR+6
             -]-1)*0x200, 512, &Exint0DataBuffer[FE_DATAADDR+9])){
 369   7                    FLASH_PageErase(SysCordAppUpdataAddrFlag);
 370   7                    FLASH_ByteWrite(SysCordAppUpdataAddrFlag, 0x5A);//Ğ´Éı¼¶±êÖ¾
 371   7                    FLASH_ByteWrite(SysCordAppUpdataAddrFlag+1, 0xA5);
 372   7                    FLASH_ByteWrite(SysCordAppUpdataAddrFlag+2, Exint0DataBuffer[FE_DATAADDR+4]);//¼ÍÂ¼Éı¼¶Êı¾İ°ü¸öÊı
 373   7                    Reply_State(CMD_UpdateSystem,1);
 374   7                    Buzzer_Beep(BuzzerTimeNormal);
 375   7                    Delay_ms(1000);
 376   7                    IAP_CONTR = 0x20;//ÖØÆô½øÈëÉı¼¶
 377   7                  }
 378   6                  }else{      
 379   6                      if(sequential_write_flash_in_one_sector(SysCordAppSaveStartTempAddr+(Exint0DataBuffer[FE_DATAADDR+
             -6]-1)*0x200, 512, &Exint0DataBuffer[FE_DATAADDR+9])){
 380   7                      Reply_State(CMD_UpdateSystem,1);
 381   7                      Buzzer_Beep(BuzzerTimeShort);
 382   7                    } 
 383   6                }
 384   5              }else if( Exint0DataBuffer[FE_DATAADDR] == 0x01)
 385   4                {
 386   5                  Muti_Send_Byte(Exint0DataBuffer,Exint0Counter);//½«Éı¼¶Êı¾İ×ª·¢¸øU2£¨ÏÂ°å£© 
 387   5                }
 388   4          }//É¾³ıËùÓĞÉí·İÖ¤
 389   3            if((CMD_DeleteAllID[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_DeleteAllID[1] ==  Exint0DataBuff
             -er[FE_MESSTYPEADDR+1])){
 390   4                for(DeleAddr=Id_StoreAddrTable[0][0];DeleAddr<Id_StoreAddrTable[10][1];DeleAddr+=0x10000){
 391   5                //SBUF = 0x76;while(!(SCON&0x02));SCON &=~0x02;
 392   5                sFLASH_64KBEraseSector(DeleAddr);
 393   5                //SBUF = 0x77;while(!(SCON&0x02));SCON &=~0x02;
 394   5                }
 395   4                Muti_Send_Byte(CommonDataBuffer,Fe_data_Organize(CMD_DeleteAllID,&CS,1,1));
 396   4            }//É¾³ıËùÓĞ¶şÎ¬Âë
 397   3            if((CMD_DeleteAllErWeiMa[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_DeleteAllErWeiMa[1] ==  Exin
             -t0DataBuffer[FE_MESSTYPEADDR+1])){
 398   4                for(DeleAddr=ErWeiMa_AddrTable[0][0];DeleAddr<ErWeiMa_AddrTable[15][1];DeleAddr+=0x10000){
 399   5                sFLASH_64KBEraseSector(DeleAddr);
 400   5                }
 401   4                Muti_Send_Byte(CommonDataBuffer,Fe_data_Organize(CMD_DeleteAllErWeiMa,&CS,1,1));
 402   4            }
 403   3            //É¾³ıËùÓĞÖ¸ÎÆID
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 8   

 404   3            if((CMD_DeleteAllUserID[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_DeleteAllUserID[1] ==  Exint0
             -DataBuffer[FE_MESSTYPEADDR+1])){
 405   4                for(DeleAddr=FingerId_AddrTable[0][0];DeleAddr<FingerId_AddrTable[15][1];DeleAddr+=0x10000){
 406   5                sFLASH_64KBEraseSector(DeleAddr);
 407   5                }
 408   4                Muti_Send_Byte(CommonDataBuffer,Fe_data_Organize(CMD_DeleteAllUserID,&CS,1,1));
 409   4            }
 410   3            //ÏÂÔØÉí·İÖ¤
 411   3            if((CMD_DownLoadUerID[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_DownLoadUerID[1] ==  Exint0Data
             -Buffer[FE_MESSTYPEADDR+1]))
 412   3            {
 413   4              if(Exint0DataBuffer[FE_DATAADDR] == 0x00){
 414   5              if(Store_IdOrErWeiMa_Data(&Exint0DataBuffer[FE_DATAADDR+1],1) == 0x01){
 415   6              Reply_State(CMD_DownLoadUerID,1);
 416   6              }else{
 417   6              Reply_State(CMD_DownLoadUerID,0);
 418   6              }
 419   5            }else if(Exint0DataBuffer[FE_DATAADDR] == 0x01)
 420   4              {
 421   5                //·¢¸øÏÂ°å×Ó½ÓÊÕ´¢´æ
 422   5                Muti_Send_Byte(Exint0DataBuffer,Exint0Counter);
 423   5              }
 424   4            }
 425   3            //É¾³ıÉí·İÖ¤
 426   3            if((CMD_DeleteID[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_DeleteID[1] ==  Exint0DataBuffer[FE_
             -MESSTYPEADDR+1]))
 427   3            {
 428   4              if(Exint0DataBuffer[FE_DATAADDR] == 0x00){
 429   5              if(Delete_IdOrErWeiMa_Info(&Exint0DataBuffer[FE_DATAADDR+1],1) == 0x01){
 430   6              Reply_State(CMD_DeleteID,1);
 431   6              }else{
 432   6              Reply_State(CMD_DeleteID,0);
 433   6              }
 434   5            }else if(Exint0DataBuffer[FE_DATAADDR] == 0x01)
 435   4              {
 436   5            //·¢¸øÏÂ°å×Ó½ÓÊÕÉ¾³ı
 437   5                Muti_Send_Byte(Exint0DataBuffer,Exint0Counter);
 438   5              }
 439   4            }
 440   3            //ÏÂÔØ¶şÎ¬Âë
 441   3            if((CMD_DownLoadErWerMa[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_DownLoadErWerMa[1] ==  Exint0
             -DataBuffer[FE_MESSTYPEADDR+1]))
 442   3            {
 443   4              if(Exint0DataBuffer[FE_DATAADDR] == 0x00){
 444   5                if(Store_IdOrErWeiMa_Data(&Exint0DataBuffer[FE_DATAADDR+1],0) == 0x01){
 445   6                Reply_State(CMD_DownLoadErWerMa,1);
 446   6                }else{
 447   6                Reply_State(CMD_DownLoadErWerMa,0);
 448   6                }
 449   5              }else if(Exint0DataBuffer[FE_DATAADDR] == 0x01)
 450   4                {
 451   5            //·¢¸øÏÂ°å×Ó½ÓÊÕ´¢´æ
 452   5                  Muti_Send_Byte(Exint0DataBuffer,Exint0Counter);
 453   5                }
 454   4            }
 455   3            //É¾³ı¶şÎ¬Âë
 456   3            if((CMD_DeleteErWeiMa[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_DeleteErWeiMa[1] ==  Exint0Data
             -Buffer[FE_MESSTYPEADDR+1]))
 457   3            {
 458   4              if(Exint0DataBuffer[FE_DATAADDR] == 0x00){
 459   5                if(Delete_IdOrErWeiMa_Info(&Exint0DataBuffer[FE_DATAADDR+1],0) == 0x01){
 460   6                  Reply_State(CMD_DeleteErWeiMa,1);
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 9   

 461   6                  }else{
 462   6                  Reply_State(CMD_DeleteErWeiMa,0);
 463   6                  }
 464   5                }else if(Exint0DataBuffer[FE_DATAADDR] == 0x01)
 465   4                {
 466   5            //·¢¸øÏÂ°å×Ó½ÓÊÕÉ¾³ı
 467   5                  Muti_Send_Byte(Exint0DataBuffer,Exint0Counter);
 468   5                }
 469   4            }//Ö¸ÎÆÍ¬²½ÏÂÔØ
 470   3            if((CMD_DownLoadFingerData[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_DownLoadFingerData[1] ==  
             -Exint0DataBuffer[FE_MESSTYPEADDR+1]))
 471   3            {
 472   4              if(LD9900MT_DownChar_ReDataProc(&Exint0DataBuffer[FE_DATAADDR+5],&Exint0DataBuffer[FE_DATAADDR+1]))
 473   4              {
 474   5                Reply_State(CMD_DownLoadFingerData,1);
 475   5              }else
 476   4              {
 477   5                Reply_State(CMD_DownLoadFingerData,0);
 478   5              }
 479   4            }//Ö¸ÎÆµ¥ÌõÉ¾³ı
 480   3              if((CMD_DeleteFingerID[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_DeleteFingerID[1] ==  Exint0D
             -ataBuffer[FE_MESSTYPEADDR+1]))
 481   3            {
 482   4              //ÏÈÕÒµ½Ö¸ÎÆID¶ÔÓ¦µÄÖ¸ÎÆ±àºÅ£¬¶ÔÖ¸ÎÆÄ£¿é½øĞĞµ¥ÌõÉ¾³ı²Ù×÷£¬È»ºóÇå¿ÕFLASHÖĞ¶ÔÓ¦µÄÖ¸ÎÆIDºÍÖ¸ÎÆ±àºÅ¶ÔÓ¦±í¡
             -£
 483   4              FLASH_W25Q64_Read(FingerStoreNumberBuffer,Search_IdOrErWeiMa_Info(&Exint0DataBuffer[FE_DATAADDR] ,0x03
             -)+6,2);//Ö¸ÎÆ±àºÅ¶ÁÈë»º³åÇø
 484   4      //        S4BUF = FingerStoreNumberBuffer[0];while(!(S4CON&0x02));S4CON &= ~0x02;
 485   4      //        S4BUF = FingerStoreNumberBuffer[1];while(!(S4CON&0x02));S4CON &= ~0x02;
 486   4              FingerStoreNumber = FingerStoreNumberBuffer[0]*256+ FingerStoreNumberBuffer[1];
 487   4              if(LD9900MT_DeleteChar(FingerStoreNumber ,1) == 0x00)//É¾³ıÖ¸ÎÆÄ£¿éÖĞµÄÊı¾İ
 488   4              {
 489   5      //        S4BUF = 0x88;while(!(S4CON&0x02));S4CON &= ~0x02;
 490   5                Delete_IdOrErWeiMa_Info(&Exint0DataBuffer[FE_DATAADDR],0x03);//Çå¿ÕFLASHÖĞ¶ÔÓ¦µÄÖ¸ÎÆIDºÍÖ¸ÎÆ±àºÅ¶ÔÓ¦±
             -í
 491   5                Reply_State(CMD_DeleteFingerID,1);
 492   5              }else
 493   4              {
 494   5                Reply_State(CMD_DeleteFingerID,1);
 495   5              }
 496   4            }     
 497   3            //Çå¿ÕÖ¸ÎÆ¿â
 498   3              if((CMD_EmptyFingerRecord[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_EmptyFingerRecord[1] ==  E
             -xint0DataBuffer[FE_MESSTYPEADDR+1])){
 499   4                    if(LD9900MT_Empty()==0x00){
 500   5                      for(DeleAddr=FingerId_AddrTable[0][0];DeleAddr<FingerId_AddrTable[15][1];DeleAddr+=0x10000){
 501   6                        sFLASH_64KBEraseSector(DeleAddr);
 502   6                        }
 503   5                      Reply_State(CMD_EmptyFingerRecord,1);
 504   5                    }else{
 505   5                      Reply_State(CMD_EmptyFingerRecord,0);
 506   5                    }
 507   4              }
 508   3              //µÚÒ»´ÎÂ¼È¡Ö¸ÎÆ    
 509   3              if((CMD_FirstRecordFinger[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_FirstRecordFinger[1] ==  E
             -xint0DataBuffer[FE_MESSTYPEADDR+1]))
 510   3                {
 511   4                  //SBUF=0xab;while(!(SCON&0X02));SCON &=~0X02;Delay_ms(100);
 512   4                  Delay_ms(100);    
 513   4                  TimeOverCounter = 0;
 514   4                while(1 == SC50x0B_Busy());
 515   4                SC50x0B_Out(PUTFINGER);
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 10  

 516   4                while(LD9900MT_GetImage(600) != 0x00 & TimeOverCounter < 10)
 517   4                {           //Ò»Ö±µÈ´ı»ñÈ¡Ö¸ÎÆÍ¼Ïñ³É¹¦  ×î¶à³¢ÊÔ10´Î
 518   5                  FirstState = 0;                                         //ÖÃ×´Ì¬Î»Îª0
 519   5                  TimeOverCounter++;
 520   5                  Buzzer_Beep(BuzzerTimeNormal);
 521   5                }
 522   4                if(TimeOverCounter < 10)
 523   4                {         
 524   5                    if(LD9900MT_GenChar(0x01,600) == 0x00){                     //Éú³ÉÌØÕ÷´¢´æÔÚ CharBuffer 1             
 525   6                    FirstState = 1;
 526   6                    Reply_State(CMD_FirstRecordFinger,1);
 527   6                    Buzzer_Beep(BuzzerTimeLong);
 528   6                    while(1 == SC50x0B_Busy());
 529   6                    SC50x0B_Out(FINGERPRINTSUCCESS);
 530   6                  }else
 531   5                  {
 532   6                    FirstState = 0;           
 533   6                    Reply_State(CMD_FirstRecordFinger,0);
 534   6                    Buzzer_Beep(BuzzerTimeShort);
 535   6                    Buzzer_Beep(BuzzerTimeShort);
 536   6                    Buzzer_Beep(BuzzerTimeShort);
 537   6                    while(1 == SC50x0B_Busy());
 538   6                    SC50x0B_Out(FINGERWRONG);
 539   6                  }
 540   5                }else
 541   4                  {
 542   5                    FirstState = 0;                                     
 543   5                    Reply_State(CMD_FirstRecordFinger,0);
 544   5                    Buzzer_Beep(BuzzerTimeShort);
 545   5                    Buzzer_Beep(BuzzerTimeShort);
 546   5                    Buzzer_Beep(BuzzerTimeShort); 
 547   5                    while(1 == SC50x0B_Busy());
 548   5                    SC50x0B_Out(INVALIDFINGER);
 549   5                  }
 550   4      
 551   4              }
 552   3                /*µÚ¶ş´ÎÂ¼È¡Ö¸ÎÆ*/
 553   3              if((CMD_SecondRecordFinger[0] ==  Exint0DataBuffer[FE_MESSTYPEADDR]) && (CMD_SecondRecordFinger[1] == 
             - Exint0DataBuffer[FE_MESSTYPEADDR+1]))/*µÚÒ»´ÎÂ¼È¡Ö¸ÎÆ*/
 554   3              {
 555   4                  Delay_ms(100);
 556   4                  TimeOverCounter = 0;//¼ÆÊıÆ÷ÇåÁã
 557   4                while(1 == SC50x0B_Busy());
 558   4                SC50x0B_Out(PUTFINGERAGAIN);
 559   4                  while(LD9900MT_GetImage(600) != 0x00 & TimeOverCounter < 10){           //Ò»Ö±µÈ´ı»ñÈ¡Ö¸ÎÆÍ¼Ïñ³É¹¦   ×î¶à³
             -¢ÊÔ10´Î
 560   5                  SecondState = 0;                                        //ÖÃ×´Ì¬Î»Îª0
 561   5                  TimeOverCounter++;  
 562   5                  Buzzer_Beep(BuzzerTimeNormal);
 563   5                  }
 564   4                  if(TimeOverCounter < 10){
 565   5                  Buzzer_Beep(BuzzerTimeLong);
 566   5                  SecondState = 1;
 567   5                  if(LD9900MT_GenChar(0x02,600) == 0x00){                 //Éú³ÉÌØÕ÷´¢´æÔÚ CharBuffer 2 
 568   6                  if(FirstState == 1 & SecondState == 1 & LD9900MT_Search(0x02,0x0000,1000,FingerStoreNumberBuffer) !=
             - 0x00){
 569   7                  FirstState = 0; 
 570   7                  SecondState = 0;
 571   7                      if(LD9900MT_CreateTemplate() == 0x00){                  //Éú³ÉÄ£°å
 572   8                          if(LD9900MT_Store(0x02,LD9900MT_SearchEmpty()) == 0x00){            //Éú³ÉÄ£°åºóCharBuffer1ºÍCharBuffe
             -r2ÖĞµÄÄÚÈİÊÇÒ»ÑùµÄ£¬´¢´æÄ£°åµ½¿âĞòºÅ1
 573   9                            //FLASH_W25Q64_Write (Search_IdOrErWeiMa_Info(UserId,0x03)+6, FingerStoreNumber, 2);
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 11  

 574   9      //                      ItemCounter = FLASH_W25Q64_ByteRead(FingerId_AddrTable[0][0])*256+FLASH_W25Q64_ByteRead(Finge
             -rId_AddrTable[0][0]+1);//¶ÁÈ¡¸ÃÇøÓò´¢´æµÄĞÅÏ¢×ÜÁ¿
 575   9      //                      FLASH_W25Q64_Update (FingerId_AddrTable[0][0]+(ItemCounter-1)*10+36, FingerStoreNumber, 2);//
             -¸üĞÂÊıÁ¿ĞÅÏ¢
 576   9      //                  FLASH_W25Q64_Read(CommonDataBuffer,FingerId_AddrTable[0][0],600);//¶ÁÈë»º³åÇø
 577   9      //       //S4BUF = 0xa2;while(!(S4CON&0x02));S4CON &= ~0x02;
 578   9      //      for(i=0;i<600;i++){
 579   9      //     S4BUF = CommonDataBuffer[i];while(!(S4CON&0x02));S4CON &= ~0x02;_nop_();_nop_();
 580   9      //    }
 581   9                            
 582   9                            LD9900MT_UpChar(0x01);        
 583   9                            LD9900MT_UpCharDataProc(CMD_SecondRecordFinger);              
 584   9                            Delay_ms(1000);
 585   9                            while(1 == SC50x0B_Busy());
 586   9                            SC50x0B_Out(FINGERPRINTSUCCESS);
 587   9                          }
 588   8                      }
 589   7                    else{               
 590   8                    Reply_State(CMD_SecondRecordFinger,0);
 591   8                    Buzzer_Beep(BuzzerTimeShort);
 592   8                    Buzzer_Beep(BuzzerTimeShort);
 593   8                    Buzzer_Beep(BuzzerTimeShort);
 594   8                    while(1 == SC50x0B_Busy());
 595   8                    SC50x0B_Out(INVALIDFINGER);
 596   8                    }
 597   7                  }
 598   6                  else{           
 599   7                    Reply_State(CMD_SecondRecordFinger,0);
 600   7                    Buzzer_Beep(BuzzerTimeShort);
 601   7                    Buzzer_Beep(BuzzerTimeShort);
 602   7                    Buzzer_Beep(BuzzerTimeShort); 
 603   7                    while(1 == SC50x0B_Busy());
 604   7                    SC50x0B_Out(INVALIDFINGER);
 605   7                  }
 606   6                  }
 607   5                  else{
 608   6                      
 609   6                    Reply_State(CMD_SecondRecordFinger,0);
 610   6                    Buzzer_Beep(BuzzerTimeShort);
 611   6                    Buzzer_Beep(BuzzerTimeShort);
 612   6                    Buzzer_Beep(BuzzerTimeShort);
 613   6                    while(1 == SC50x0B_Busy());
 614   6                    SC50x0B_Out(FINGERWRONG);
 615   6                  }
 616   5                  }
 617   4                  else{
 618   5                        SecondState = 0;                
 619   5                        Reply_State(CMD_SecondRecordFinger,0);
 620   5                    Buzzer_Beep(BuzzerTimeShort);
 621   5                    Buzzer_Beep(BuzzerTimeShort);
 622   5                    Buzzer_Beep(BuzzerTimeShort);
 623   5                    while(1 == SC50x0B_Busy());
 624   5                    SC50x0B_Out(INVALIDFINGER);
 625   5                  }
 626   4                  }
 627   3        }
 628   2      }
 629   1      
 630   1        memset(Exint0DataBuffer,0x00,600);
 631   1        Exint0Counter = 0;
 632   1      
 633   1      }
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 12  

 634          
 635          //»Ø¸´ÉÏÎ»»ú
 636          void Reply_State(unsigned char CMD[],unsigned char  State){
 637   1      unsigned int Reply_Num = 0;
 638   1      unsigned char const ReplySucc = 0x31;   
 639   1      unsigned char const ReplyFail = 0x30;
 640   1      //        SBUF = 0xaf;while(!(SCON&0x02));SCON &= ~0x02;
 641   1        if(State == 1){
 642   2          Reply_Num =  Fe_data_Organize(CMD,&ReplySucc,1,0);
 643   2          Muti_Send_Byte(CommonDataBuffer,Reply_Num);
 644   2      }else if(State == 0){
 645   2          Reply_Num =  Fe_data_Organize(CMD,&ReplyFail,1,0);
 646   2          Muti_Send_Byte(CommonDataBuffer,Reply_Num);
 647   2      }
 648   1        memset(CommonDataBuffer,0x00,600);
 649   1      }
 650          
 651          void Buzzer_Beep(unsigned char TimeFlag){
 652   1        unsigned int Reply_Num = 0;
 653   1        Delay_ms(100);
 654   1            Reply_Num =  Fe_data_Organize(CMD_Buzzer,&TimeFlag,1,1);
 655   1            Muti_Send_Byte(CommonDataBuffer,Reply_Num);
 656   1        memset(CommonDataBuffer,0x00,600);
 657   1      }
 658          
 659          
 660          
 661          
 662          //´¢´æĞÅÏ¢
 663          unsigned char Store_IdOrErWeiMa_Data(unsigned char *Data,UCHAR SecletFlag){
 664   1      UINT  i=0;
 665   1      UINT  ItemCounter=0;//¸ÃÇøÓòµÄÓÃ»§ĞÅÏ¢ÊıÁ¿
 666   1      UCHAR ItemCounterBuffer[2] = {0},Cursor = 0;
 667   1      UCHAR TempIdBuffer[20]={0};
 668   1      UCHAR StoreErWeiMaBuffer[10]={0};
 669   1      UCHAR StoreFingerIdBuffer[10]={0};
 670   1      UCHAR AttachData[6]={0xff,0xff,0xff,0xff,0xff,0xff};
 671   1      //Éí·İÖ¤
 672   1      if(SecletFlag == 0x01){
 673   2      for(i=0;i<16;i++)
 674   2        {
 675   3          TempIdBuffer[i] = *Data++;  //Ôİ´æµÚÒ»ÌõĞÅÏ¢
 676   3        }
 677   2        Arraycat(TempIdBuffer,AttachData,16,4); //Ìí¼Ó¸½¼ÓĞÅÏ¢
 678   2        Cursor = TempIdBuffer[8];
 679   2        if(Search_IdOrErWeiMa_Info(TempIdBuffer,1) == 0){//ĞÅÏ¢²»´æÔÚÔòÌí¼Ó
 680   3          ItemCounter = FLASH_W25Q64_ByteRead(Id_StoreAddrTable[Cursor&= 0x0f][0])*256+FLASH_W25Q64_ByteRead(Id_St
             -oreAddrTable[Cursor&= 0x0f][0]+1);//¶ÁÈ¡¸ÃÇøÓò´¢´æµÄĞÅÏ¢×ÜÁ¿
 681   3           SBUF = 0xa5;while(!(SCON&0x02));SCON &= ~0x02;
 682   3        //¸ù¾İÉí·İÖ¤Ğ£ÑéÂë10ÖÖ·ÖÀà´¢´æ²»Í¬µÄÇøÓò
 683   3          if(ItemCounter == 0xffff)//³õÊ¼»¯¹¤×÷
 684   3          ItemCounter = 0;
 685   3      
 686   3          FLASH_W25Q64_Write ( Id_StoreAddrTable[Cursor&= 0x0f][0]+ItemCounter*20+60,TempIdBuffer, 20);//ÔÚÎ²²¿×·¼
             -ÓĞÅÏ¢ Ã¿¸öÇøÓòÇ°60×Ö½ÚÔ¤Áô
 687   3      
 688   3          ItemCounter ++;//ÊıÁ¿Ôö¼Ó1
 689   3        //  SBUF = 0xa6;while(!(SCON&0x02));SCON &= ~0x02;
 690   3          ItemCounterBuffer[0] = (ItemCounter & 0xff00)>>8;
 691   3          ItemCounterBuffer[1] = ItemCounter & 0x00ff;
 692   3          FLASH_W25Q64_Update (Id_StoreAddrTable[Cursor&= 0x0f][0], ItemCounterBuffer, 2);//¸üĞÂÊıÁ¿ĞÅÏ¢
 693   3      //        SBUF = 0xa2;while(!(SCON&0x02));SCON &= ~0x02;
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 13  

 694   3      //        FLASH_W25Q64_Read(CommonDataBuffer,Id_StoreAddrTable[Cursor&= 0x0f][0],600);//¶ÁÈë»º³åÇø
 695   3      //      for(i=0;i<600;i++){
 696   3      //       SBUF = CommonDataBuffer[i];while(!(SCON&0x02));SCON &= ~0x02;_nop_();_nop_();
 697   3      //      }
 698   3      //   SBUF = 0xa7;while(!(SCON&0x02));SCON &= ~0x02;
 699   3        }else{
 700   3          return 1;
 701   3        }
 702   2        return 1;
 703   2      }else if(SecletFlag == 0x00)
 704   1      //¶şÎ¬Âë
 705   1      {
 706   2      for(i=0;i<6;i++)
 707   2        {
 708   3          StoreErWeiMaBuffer[i] = *Data++;  //Ôİ´æµÚÒ»ÌõĞÅÏ¢
 709   3        }
 710   2          Arraycat(StoreErWeiMaBuffer,AttachData,6,4);  //Ìí¼Ó¸½¼ÓĞÅÏ¢
 711   2          if(Search_IdOrErWeiMa_Info(StoreErWeiMaBuffer,0x00) == 0){//ĞÅÏ¢²»´æÔÚÔòÌí¼Ó
 712   3          Cursor = StoreErWeiMaBuffer[5] ;
 713   3      //    for(i=0;i<6;i++){
 714   3      //    SBUF = StoreErWeiMaBuffer[i];while(!(SCON&0x02));SCON &= ~0x02;_nop_();
 715   3      //      }
 716   3      
 717   3        ItemCounter = FLASH_W25Q64_ByteRead(ErWeiMa_AddrTable[Cursor&= 0x0f][0])*256+FLASH_W25Q64_ByteRead(ErWeiM
             -a_AddrTable[Cursor&= 0x0f][0]+1);//¶ÁÈ¡¸ÃÇøÓò´¢´æµÄĞÅÏ¢×ÜÁ¿
 718   3      //   SBUF = 0xa5;while(!(SCON&0x02));SCON &= ~0x02;
 719   3      //¸ù¾İĞ£ÑéÂë16ÖÖ·ÖÀà´¢´æ²»Í¬µÄÇøÓò
 720   3        if(ItemCounter == 0xffff)//³õÊ¼»¯¹¤×÷
 721   3        ItemCounter = 0;
 722   3      
 723   3                for(i=0;i<10;i++){
 724   4          SBUF = StoreErWeiMaBuffer[i];while(!(SCON&0x02));SCON &= ~0x02;_nop_();
 725   4            }
 726   3                
 727   3        FLASH_W25Q64_Write (ErWeiMa_AddrTable[Cursor&= 0x0f][0]+ItemCounter*10+30, StoreErWeiMaBuffer, 10);//ÔÚÎ²
             -²¿×·¼ÓĞÅÏ¢ Ã¿¸öÇøÓòÇ°30×Ö½ÚÔ¤Áô
 728   3        ItemCounter ++;//ÊıÁ¿Ôö¼Ó1
 729   3      //  SBUF = 0xa6;while(!(SCON&0x02));SCON &= ~0x02;
 730   3        ItemCounterBuffer[0] = (ItemCounter & 0xff00)>>8;
 731   3        ItemCounterBuffer[1] = ItemCounter & 0x00ff;
 732   3        FLASH_W25Q64_Update (ErWeiMa_AddrTable[Cursor&= 0x0f][0], ItemCounterBuffer, 2);//¸üĞÂÊıÁ¿ĞÅÏ¢
 733   3      //   SBUF = 0xa7;while(!(SCON&0x02));SCON &= ~0x02;
 734   3        //  FLASH_W25Q64_Write ( ErWeiMa_AddrTable[1][0]+5*10+30,erweima, 10);
 735   3      //  memset(CommonDataBuffer,0x00,600);
 736   3          FLASH_W25Q64_Read(CommonDataBuffer,ErWeiMa_AddrTable[Cursor&= 0x0f][0],600);//¶ÁÈë»º³åÇø
 737   3             SBUF = 0xa2;while(!(SCON&0x02));SCON &= ~0x02;
 738   3          for(i=0;i<600;i++){
 739   4           SBUF = CommonDataBuffer[i];while(!(SCON&0x02));SCON &= ~0x02;_nop_();_nop_();
 740   4          }
 741   3          return 1;
 742   3        }else{
 743   3          return 1;
 744   3        }
 745   2        return 1;
 746   2      }//ÓÃ»§ID
 747   1      else if(SecletFlag == 0x03)
 748   1      {
 749   2      for(i=0;i<4;i++)
 750   2        {
 751   3          StoreFingerIdBuffer[i] = *Data++; //Ôİ´æµÚÒ»ÌõĞÅÏ¢
 752   3        }
 753   2          if(Search_IdOrErWeiMa_Info(StoreFingerIdBuffer,0x03) == 0){//ĞÅÏ¢²»´æÔÚÔòÌí¼Ó
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 14  

 754   3          Arraycat(StoreFingerIdBuffer,AttachData,4,6); //Ìí¼Ó¸½¼ÓĞÅÏ¢
 755   3          Cursor = StoreFingerIdBuffer[0]+StoreFingerIdBuffer[1]+StoreFingerIdBuffer[2]+StoreFingerIdBuffer[3] ;
 756   3      //    for(i=0;i<6;i++){
 757   3      //    SBUF = StoreErWeiMaBuffer[i];while(!(SCON&0x02));SCON &= ~0x02;_nop_();
 758   3      //      }
 759   3      
 760   3        ItemCounter = FLASH_W25Q64_ByteRead(FingerId_AddrTable[Cursor&= 0x0f][0])*256+FLASH_W25Q64_ByteRead(Finge
             -rId_AddrTable[Cursor&= 0x0f][0]+1);//¶ÁÈ¡¸ÃÇøÓò´¢´æµÄĞÅÏ¢×ÜÁ¿
 761   3      //   SBUF = 0xa5;while(!(SCON&0x02));SCON &= ~0x02;
 762   3      //¸ù¾İĞ£ÑéÂë16ÖÖ·ÖÀà´¢´æ²»Í¬µÄÇøÓò
 763   3        if(ItemCounter == 0xffff)//³õÊ¼»¯¹¤×÷
 764   3        ItemCounter = 0;
 765   3      
 766   3      //          for(i=0;i<10;i++){
 767   3      //    S4BUF = StoreFingerIdBuffer[i];while(!(S4CON&0x02));S4CON &= ~0x02;_nop_();
 768   3      //      }
 769   3                
 770   3        FLASH_W25Q64_Write (FingerId_AddrTable[Cursor&= 0x0f][0]+ItemCounter*10+30, StoreFingerIdBuffer, 10);//ÔÚ
             -Î²²¿×·¼ÓĞÅÏ¢ Ã¿¸öÇøÓòÇ°30×Ö½ÚÔ¤Áô
 771   3        ItemCounter ++;//ÊıÁ¿Ôö¼Ó1
 772   3      //  SBUF = 0xa6;while(!(SCON&0x02));SCON &= ~0x02;
 773   3        ItemCounterBuffer[0] = (ItemCounter & 0xff00)>>8;
 774   3        ItemCounterBuffer[1] = ItemCounter & 0x00ff;
 775   3        FLASH_W25Q64_Update (FingerId_AddrTable[Cursor&= 0x0f][0], ItemCounterBuffer, 2);//¸üĞÂÊıÁ¿ĞÅÏ¢
 776   3      //   SBUF = 0xa7;while(!(SCON&0x02));SCON &= ~0x02;
 777   3      //  memset(CommonDataBuffer,0x00,600);
 778   3      //    FLASH_W25Q64_Read(CommonDataBuffer,FingerId_AddrTable[Cursor&= 0x0f][0],600);//¶ÁÈë»º³åÇø
 779   3             //S4BUF = 0xa2;while(!(S4CON&0x02));S4CON &= ~0x02;
 780   3      //    for(i=0;i<600;i++){
 781   3      //     S4BUF = CommonDataBuffer[i];while(!(S4CON&0x02));S4CON &= ~0x02;_nop_();_nop_();
 782   3      //    }
 783   3          return 1;
 784   3        }else{
 785   3          return 1;
 786   3        }
 787   2        return 1;
 788   2      }
 789   1      
 790   1      return 1;
 791   1      }
 792          
 793          
 794          //ËÑË÷Éí·İÖ¤ĞÅÏ¢ ·µ»ØËùÔÚµØÖ·»òÕß0£¨Ã»ÓĞËÑË÷µ½ĞÅÏ¢£©
 795          unsigned long int Search_IdOrErWeiMa_Info(UCHAR *Data,UCHAR SecletFlag){
 796   1      
 797   1      UCHAR TempIdData[9],*Result_Addr,Cursor = 0;
 798   1      UCHAR TempErWeiMaBuffer[6]={0};
 799   1      UCHAR TempFingerIdBuffer[4]={0};
 800   1      ULONG CurrentAddr = 0;
 801   1      UINT i=0,ItemCounter=0,Comparei = 0;
 802   1        if( SecletFlag == 0x01){
 803   2          for(i=0;i<9;i++){
 804   3          TempIdData[i] = *Data++;
 805   3          }
 806   2          Cursor = TempIdData[8];
 807   2      //      for(i=0;i<9;i++){
 808   2      //    SBUF = TempIdData[i];while(!(SCON&0x02));SCON &= ~0x02;_nop_();
 809   2      //      }
 810   2          ItemCounter = FLASH_W25Q64_ByteRead(Id_StoreAddrTable[Cursor &= 0x0f][0])*256+FLASH_W25Q64_ByteRead(Id_S
             -toreAddrTable[Cursor &= 0x0f][0]+1);//¶ÁÈ¡¸ÃÇøÓò´¢´æµÄĞÅÏ¢×ÜÁ¿
 811   2            if(ItemCounter == 0xffff)
 812   2              ItemCounter = 0;
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 15  

 813   2          for(CurrentAddr = Id_StoreAddrTable[Cursor&= 0x0f][0];CurrentAddr<Id_StoreAddrTable[Cursor&= 0x0f][0]+It
             -emCounter*20+60;CurrentAddr+=600){
 814   3               FLASH_W25Q64_Read(CommonDataBuffer,CurrentAddr,600);//¶ÁÈë»º³åÇø
 815   3               SBUF = 0xa2;while(!(SCON&0x02));SCON &= ~0x02;
 816   3               Result_Addr = CommonDataBuffer;
 817   3                for(i=0;i<600;i+=20){
 818   4                  if(Bytencmp(Result_Addr,TempIdData,9) != 0){
 819   5                  Result_Addr+=20;
 820   5                  Comparei++;
 821   5                  }
 822   4                else
 823   4                {
 824   5                  memset(CommonDataBuffer,0x00,600);
 825   5                  return Id_StoreAddrTable[Cursor&= 0x0f][0]+Comparei*20;
 826   5                }
 827   4              }
 828   3            }
 829   2        }else if(SecletFlag == 0x00){
 830   2        for(i=0;i<6;i++){
 831   3          TempErWeiMaBuffer[i] = *Data++;
 832   3        }
 833   2          for(i=0;i<6;i++){
 834   3          SBUF = TempErWeiMaBuffer[i];while(!(SCON&0x02));SCON &= ~0x02;_nop_();
 835   3            }
 836   2          Cursor = TempErWeiMaBuffer[5];
 837   2          ItemCounter = FLASH_W25Q64_ByteRead(ErWeiMa_AddrTable[Cursor &= 0x0f][0])*256+FLASH_W25Q64_ByteRead(ErWe
             -iMa_AddrTable[Cursor &= 0x0f][0]+1);//¶ÁÈ¡¸ÃÇøÓò´¢´æµÄĞÅÏ¢×ÜÁ¿
 838   2            if(ItemCounter == 0xffff)
 839   2              ItemCounter = 0;
 840   2            for(CurrentAddr = ErWeiMa_AddrTable[Cursor&= 0x0f][0];CurrentAddr<ErWeiMa_AddrTable[Cursor&= 0x0f][0]+I
             -temCounter*10+30;CurrentAddr+=600){
 841   3               FLASH_W25Q64_Read(CommonDataBuffer,CurrentAddr,600);//¶ÁÈë»º³åÇø
 842   3               SBUF = 0xa2;while(!(SCON&0x02));SCON &= ~0x02;
 843   3               Result_Addr = CommonDataBuffer;
 844   3                for(i=0;i<600;i+=10){
 845   4                  if(Bytencmp(Result_Addr,TempErWeiMaBuffer,6) != 0){
 846   5                  Result_Addr+=10;
 847   5                  Comparei++;//¼ÍÂ¼´ÎÊı
 848   5                  }
 849   4                else
 850   4                {
 851   5                  memset(CommonDataBuffer,0x00,600);
 852   5                  return ErWeiMa_AddrTable[Cursor&= 0x0f][0]+Comparei*10;
 853   5                }
 854   4              }
 855   3            }
 856   2          }else if(SecletFlag == 0x03){
 857   2            for(i=0;i<4;i++){
 858   3          TempFingerIdBuffer[i] = *Data++;
 859   3        }
 860   2      //    for(i=0;i<4;i++){
 861   2      //    S4BUF = TempFingerIdBuffer[i];while(!(S4CON&0x02));S4CON &= ~0x02;_nop_();
 862   2      //      }
 863   2              Cursor = TempFingerIdBuffer[0]+TempFingerIdBuffer[1]+TempFingerIdBuffer[2]+TempFingerIdBuffer[3] ;
 864   2          ItemCounter = FLASH_W25Q64_ByteRead(FingerId_AddrTable[Cursor &= 0x0f][0])*256+FLASH_W25Q64_ByteRead(Fin
             -gerId_AddrTable[Cursor &= 0x0f][0]+1);//¶ÁÈ¡¸ÃÇøÓò´¢´æµÄĞÅÏ¢×ÜÁ¿
 865   2            if(ItemCounter == 0xffff)
 866   2              ItemCounter = 0;
 867   2            for(CurrentAddr = FingerId_AddrTable[Cursor&= 0x0f][0];CurrentAddr<FingerId_AddrTable[Cursor&= 0x0f][0]
             -+ItemCounter*10+30;CurrentAddr+=600){
 868   3              memset(CommonDataBuffer,0x00,600);
 869   3              FLASH_W25Q64_Read(CommonDataBuffer,CurrentAddr,600);//¶ÁÈë»º³åÇø
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 16  

 870   3      //            for(i=0;i<600;i++){
 871   3      //     S4BUF = CommonDataBuffer[i];while(!(S4CON&0x02));S4CON &= ~0x02;_nop_();_nop_();
 872   3      //    }
 873   3               S4BUF = 0xa2;while(!(S4CON&0x02));S4CON &= ~0x02;
 874   3               Result_Addr = CommonDataBuffer;
 875   3                for(i=0;i<600;i+=10){
 876   4      //            S4BUF = i>>8;while(!(S4CON&0x02));S4CON &= ~0x02;
 877   4      //            S4BUF = i;while(!(S4CON&0x02));S4CON &= ~0x02;
 878   4      //            S4BUF = strncmp(Result_Addr,TempFingerIdBuffer,4)>>8;while(!(S4CON&0x02));S4CON &= ~0x02;
 879   4      //            S4BUF = strncmp(Result_Addr,TempFingerIdBuffer,4);while(!(S4CON&0x02));S4CON &= ~0x02;
 880   4      //            S4BUF = *(  Result_Addr+=30);while(!(S4CON&0x02));S4CON &= ~0x02;
 881   4      //            S4BUF = *(  Result_Addr++);while(!(S4CON&0x02));S4CON &= ~0x02;
 882   4      //            S4BUF = *(  Result_Addr++);while(!(S4CON&0x02));S4CON &= ~0x02;
 883   4      //            S4BUF = *(  Result_Addr++);while(!(S4CON&0x02));S4CON &= ~0x02;
 884   4                  if(Bytencmp(Result_Addr,TempFingerIdBuffer,4) != 0){
 885   5                  Result_Addr+=10;
 886   5                  Comparei++;//¼ÍÂ¼´ÎÊı
 887   5      //            S4BUF = Comparei>>8;while(!(S4CON&0x02));S4CON &= ~0x02;
 888   5      //            S4BUF = Comparei;while(!(S4CON&0x02));S4CON &= ~0x02;
 889   5      //              S4BUF = Result_Addr>>16;while(!(S4CON&0x02));S4CON &= ~0x02;
 890   5      //              S4BUF = Result_Addr>>8;while(!(S4CON&0x02));S4CON &= ~0x02;
 891   5      //              S4BUF = Result_Addr;while(!(S4CON&0x02));S4CON &= ~0x02;
 892   5      //              S4BUF = Comparei>>8;while(!(S4CON&0x02));S4CON &= ~0x02;
 893   5      //                S4BUF = Comparei;while(!(S4CON&0x02));S4CON &= ~0x02;
 894   5                  }
 895   4                else
 896   4                {
 897   5                  memset(CommonDataBuffer,0x00,600);
 898   5                  return FingerId_AddrTable[Cursor&= 0x0f][0]+Comparei*10;
 899   5                }
 900   4              }
 901   3            }
 902   2          
 903   2          }
 904   1      memset(CommonDataBuffer,0x00,600);
 905   1      return 0;
 906   1      }
 907          
 908          /***********************************************
 909          º¯ÊıÃû³Æ£ºBytencmp
 910          º¯Êı¹¦ÄÜ£º±È¶Ô
 911          Èë¿Úº¯Êı£º*src  *dest  len
 912          ³öºó¿ÚÊı£ºÎŞ
 913          ***********************************************/
 914          unsigned char Bytencmp(unsigned char *src,unsigned char *dest,unsigned int len)
 915          {
 916   1        unsigned int i=0;
 917   1        for(i=0;i<len;i++)
 918   1        {
 919   2      //    S4BUF = *(src+i);while(!(S4CON&0x02));S4CON &= ~0x02;
 920   2      //    S4BUF = 0xaa;while(!(S4CON&0x02));S4CON &= ~0x02;
 921   2      //    S4BUF = *(dest+i);while(!(S4CON&0x02));S4CON &= ~0x02;
 922   2          if(*(src+i) != *(dest+i)){
 923   3          return 1;
 924   3          }else
 925   2          {
 926   3          ;
 927   3          }
 928   2        }
 929   1          //S4BUF = i;while(!(S4CON&0x02));S4CON &= ~0x02;
 930   1        if(i==len)
 931   1      { 
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 17  

 932   2      //  S4BUF = 0xaa;while(!(S4CON&0x02));S4CON &= ~0x02;
 933   2        return 0;
 934   2      }
 935   1          return 1;
 936   1      }
 937          
 938          //É¾³ıÉí·İÖ¤ĞÅÏ¢  ·µ»Ø0£¨É¾³ıÊ§°Ü£©»òÕß1£¨É¾³ı³É¹¦£©
 939          UCHAR Delete_IdOrErWeiMa_Info(UCHAR *IdData,UCHAR SecletFlag){
 940   1        UINT  ItemCounter=0;//¸ÃÇøÓòµÄÓÃ»§ĞÅÏ¢ÊıÁ¿
 941   1        UCHAR ItemCounterBuffer[2] = {0},Cursor = 0;
 942   1        UCHAR DelErWeiMaBuffer[6]={0};
 943   1        UCHAR DelFingerIdBuffer[4]={0};
 944   1        ULONG TempAddr = 0;
 945   1        UCHAR TempIdData[9] ={0};
 946   1        UCHAR TempFlashBuffer[20]= {0};
 947   1        UINT i;
 948   1          if(SecletFlag == 0x01){
 949   2          for(i=0;i<9;i++)
 950   2          TempIdData[i] = *IdData++;
 951   2            Cursor = TempIdData[8];
 952   2          ItemCounter = FLASH_W25Q64_ByteRead(Id_StoreAddrTable[Cursor&= 0x0f][0])*256+FLASH_W25Q64_ByteRead(Id_St
             -oreAddrTable[Cursor&= 0x0f][0]+1);//¶ÁÈ¡¸ÃÇøÓò´¢´æµÄĞÅÏ¢×ÜÁ¿
 953   2          TempAddr = Search_IdOrErWeiMa_Info(TempIdData,1);
 954   2          if(TempAddr == 0){
 955   3          return 1;
 956   3          }else{
 957   3            FLASH_W25Q64_Read(TempFlashBuffer,Id_StoreAddrTable[Cursor&= 0x0f][0]+ItemCounter*20+60,20);
 958   3            FLASH_W25Q64_Update (TempAddr, TempFlashBuffer, 20);//½«Î²²¿µÄÒ»ÌõĞÅÏ¢×·¼Óµ½É¾³ıµÄÎ»ÖÃ
 959   3            memset(TempFlashBuffer,0xff,20);
 960   3            FLASH_W25Q64_Update (Id_StoreAddrTable[Cursor &= 0x0f][0]+ItemCounter*20+60,TempFlashBuffer , 20);//É¾³
             -ıÄ©Î²µÄÒ»ÌõĞÅÏ¢
 961   3            ItemCounter--;//ÊıÁ¿¼õ1
 962   3            ItemCounterBuffer[0] = (ItemCounter & 0xff00)>>8;
 963   3            ItemCounterBuffer[1] = ItemCounter & 0x00ff;
 964   3            FLASH_W25Q64_Update (Id_StoreAddrTable[Cursor&= 0x0f][0], ItemCounterBuffer, 2);//¸üĞÂÊıÁ¿ĞÅÏ¢
 965   3            return 1;
 966   3          }
 967   2        }else if(SecletFlag == 0x00){
 968   2          for(i=0;i<6;i++)
 969   2          DelErWeiMaBuffer[i] = *IdData++;
 970   2          Cursor  = DelErWeiMaBuffer[5];
 971   2          ItemCounter = FLASH_W25Q64_ByteRead(ErWeiMa_AddrTable[Cursor&= 0x0f][0])*256+FLASH_W25Q64_ByteRead(ErWei
             -Ma_AddrTable[Cursor&= 0x0f][0]+1);//¶ÁÈ¡¸ÃÇøÓò´¢´æµÄĞÅÏ¢×ÜÁ¿
 972   2          TempAddr = Search_IdOrErWeiMa_Info(DelErWeiMaBuffer,0);
 973   2          if(TempAddr == 0){
 974   3          return 1;
 975   3          }else{
 976   3            FLASH_W25Q64_Read(TempFlashBuffer,ErWeiMa_AddrTable[Cursor&= 0x0f][0]+ItemCounter*10+30,10);
 977   3            FLASH_W25Q64_Update (TempAddr, TempFlashBuffer, 10);//½«Î²²¿µÄÒ»ÌõĞÅÏ¢×·¼Óµ½É¾³ıµÄÎ»ÖÃ
 978   3            memset(TempFlashBuffer,0xff,10);
 979   3            FLASH_W25Q64_Update ((ErWeiMa_AddrTable[Cursor&= 0x0f][0]+ItemCounter*10+30),TempFlashBuffer , 10);//É¾
             -³ıÄ©Î²µÄÒ»ÌõĞÅÏ¢
 980   3            ItemCounter--;//ÊıÁ¿¼õ1
 981   3            ItemCounterBuffer[0] = (ItemCounter & 0xff00)>>8;
 982   3            ItemCounterBuffer[1] = ItemCounter & 0x00ff;
 983   3            FLASH_W25Q64_Update (ErWeiMa_AddrTable[Cursor&= 0x0f][0], ItemCounterBuffer, 2);//¸üĞÂÊıÁ¿ĞÅÏ¢
 984   3            return 1;
 985   3          }
 986   2        }else if(SecletFlag == 0x03){
 987   2          for(i=0;i<4;i++)
 988   2          DelFingerIdBuffer[i] = *IdData++;
 989   2          Cursor = DelFingerIdBuffer[0]+DelFingerIdBuffer[1]+DelFingerIdBuffer[2]+DelFingerIdBuffer[3] ;
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 18  

 990   2          ItemCounter = FLASH_W25Q64_ByteRead(FingerId_AddrTable[Cursor&= 0x0f][0])*256+FLASH_W25Q64_ByteRead(Fing
             -erId_AddrTable[Cursor&= 0x0f][0]+1);//¶ÁÈ¡¸ÃÇøÓò´¢´æµÄĞÅÏ¢×ÜÁ¿
 991   2          TempAddr = Search_IdOrErWeiMa_Info(DelFingerIdBuffer,3);
 992   2          if(TempAddr == 0){
 993   3          return 1;
 994   3          }else{
 995   3            FLASH_W25Q64_Read(TempFlashBuffer,FingerId_AddrTable[Cursor&= 0x0f][0]+ItemCounter*10+30,10);
 996   3            FLASH_W25Q64_Update (TempAddr, TempFlashBuffer, 10);//½«Î²²¿µÄÒ»ÌõĞÅÏ¢×·¼Óµ½É¾³ıµÄÎ»ÖÃ
 997   3            memset(TempFlashBuffer,0xff,10);
 998   3            FLASH_W25Q64_Update ((FingerId_AddrTable[Cursor&= 0x0f][0]+ItemCounter*10+30),TempFlashBuffer , 10);//É
             -¾³ıÄ©Î²µÄÒ»ÌõĞÅÏ¢
 999   3            ItemCounter--;//ÊıÁ¿¼õ1
1000   3            ItemCounterBuffer[0] = (ItemCounter & 0xff00)>>8;
1001   3            ItemCounterBuffer[1] = ItemCounter & 0x00ff;
1002   3            FLASH_W25Q64_Update (FingerId_AddrTable[Cursor&= 0x0f][0], ItemCounterBuffer, 2);//¸üĞÂÊıÁ¿ĞÅÏ¢
1003   3            return 1;
1004   3          }
1005   2        }
1006   1        return 0;
1007   1      }
1008          
1009          
1010          
1011          /*****************************************************************************/
1012          /*Éí·İÖ¤ÊÕ·¢´¦Àí³ÌĞò*/
1013          /*³ÌĞò×éµ±ÊÕµ½ÓĞĞ§Ö¡ºó½øĞĞÏÂÒ»²½´¦Àí³ÌĞò                                     */
1014          /*Èë¿Ú²ÎÊı£ºÎŞ                         */
1015          /*   ·µ»ØÖµ£º ÕûĞÍ£¬Îªµ±Ç°DataSortBufferÊı×éÓĞĞ§Êı¾İµÄ¸öÊı                    */
1016          /*Ö¡½á¹¹Îª Ö¡Í· Êı¾İ³¤¶È Ä¿±êµØÖ· ĞòÁĞºÅ ÃüÁî Êı¾İ Ğ£ÑéºÍ Ö¡Î²               */
1017          /*****************************************************************************/
1018          void Uart4_DATA_deal(void)
1019          { 
1020   1      //  unsigned char FindACKBuffer[20] = {0};
1021   1      //  const unsigned char code FIND_CARD_FAILURE_ACK[12]={0xaa, 0xaa, 0xaa, 0x96, 0x69,0x00,0x04, 0x00,0x00,0
             -x80,0x84,0x00};
1022   1      //  const unsigned char code FIND_CARD_SUCCEES_ACK[16]={0xaa, 0xaa, 0xaa, 0x96, 0x69,0x00,0x08, 0x00,0x00,0
             -x9F,0x00,0x00,0x00,0x00,0x97,0x00};
1023   1        unsigned int i = 0,j = 0;
1024   1        unsigned char IdNumberAscii[18] = {0};
1025   1        unsigned char Id_BCD_Buffer[9] = 0;
1026   1          if((Flag_FindCard_500msOver == 1)&& ( UserCardReadState == STATE_NOCARD)){
1027   2            Flag_FindCard_500msOver=0;
1028   2          USART4_Send(FIND_CARD,sizeof(FIND_CARD));
1029   2          Delay_ms(100);
1030   2              if( Uart4FindCartACK[6] == 0x04){//Ñ°¿¨Ê§°Ü
1031   3        //    SBUF=Uart4ACKCounter>>8;while(!(SCON&0x02));SCON &=~0x02; _nop_();
1032   3        //    SBUF=Uart4ACKCounter;while(!(SCON&0x02));SCON &=~0x02;  _nop_();
1033   3      //      for(i=0;i<Uart4ACKCounter;i++){
1034   3      //        SBUF=Uart4FindCartACK[i];
1035   3      //        while(!(SCON&0x02));
1036   3      //        SCON &=~0x02;
1037   3      //        _nop_();
1038   3      //      }
1039   3          }else if(Uart4FindCartACK[6] == 0x08){//Ñ°¿¨³É¹¦
1040   3            UserCardReadState = STATE_SELECTCARD;
1041   3      //        SBUF=0x35;while(!(SCON&0x02));SCON &=~0x02; _nop_();
1042   3      //        for(i=0;i<Uart4ACKCounter;i++){
1043   3      //        SBUF=Uart4FindCartACK[i];
1044   3      //        while(!(SCON&0x02));
1045   3      //        SCON &=~0x02;
1046   3      //        _nop_();
1047   3      //      }
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 19  

1048   3      //        SBUF=0x36;while(!(SCON&0x02));SCON &=~0x02; _nop_();
1049   3              Uart4ACKCounter = 0;
1050   3      //        _nop_();  _nop_();
1051   3              USART4_Send(SELECT_CARD,sizeof(SELECT_CARD));//Ñ¡¿¨
1052   3      //              SBUF=0x37;while(!(SCON&0x02));SCON &=~0x02; _nop_();
1053   3                Delay_ms(100);
1054   3      //              SBUF=0x38;while(!(SCON&0x02));SCON &=~0x02; _nop_();
1055   3          }
1056   2        }
1057   1            if(UserCardReadState == STATE_SELECTCARD){
1058   2      //        for(i=0;i<Uart4ACKCounter;i++){
1059   2      //        SBUF=Uart4FindCartACK[i];while(!(SCON&0x02));SCON &=~0x02;
1060   2      //      }
1061   2      //        SBUF=0x88;while(!(SCON&0x02));SCON &=~0x02; _nop_();
1062   2                if( Uart4FindCartACK[6] == 0x04){//Ñ¡¿¨Ê§°Ü
1063   3      
1064   3      //            SBUF=0x23;while(!(SCON&0x02));SCON &=~0x02;
1065   3                  UserCardReadState = STATE_NOCARD;
1066   3                  Flag_FindCard_500msOver=0;
1067   3      //            SBUF=0x59;while(!(SCON&0x02));SCON &=~0x02;
1068   3          //    SBUF=Uart4ACKCounter>>8;while(!(SCON&0x02));SCON &=~0x02; _nop_();
1069   3          //    SBUF=Uart4ACKCounter;while(!(SCON&0x02));SCON &=~0x02;  _nop_();
1070   3      //        for(i=0;i<Uart4ACKCounter;i++){
1071   3      //          SBUF=Uart4FindCartACK[i];
1072   3      //          while(!(SCON&0x02));
1073   3      //          SCON &=~0x02;
1074   3      //          _nop_();
1075   3      //        }
1076   3            }else if(Uart4FindCartACK[6] == 0x0c){//Ñ¡¿¨³É¹¦
1077   3            UserCardReadState = STATE_READCARD;
1078   3      //        SBUF=0x05;while(!(SCON&0x02));SCON &=~0x02;
1079   3      //        for(i=0;i<Uart4ACKCounter;i++){
1080   3      //        SBUF=Uart4FindCartACK[i];while(!(SCON&0x02));SCON &=~0x02;
1081   3      
1082   3      //      }
1083   3      //          SBUF=0xff;while(!(SCON&0x02));SCON &=~0x02; _nop_();
1084   3              Uart4ACKCounter = 0;
1085   3              USART4_Send(READ_CARD,sizeof(READ_CARD));//¶Á¿¨
1086   3                
1087   3          }
1088   2        }
1089   1            
1090   1          if(UserCardReadState == STATE_READCARD){
1091   2      //        for(i=0;i<Uart4ACKCounter;i++){
1092   2      //        SBUF=Uart4FindCartACK[i];while(!(SCON&0x02));SCON &=~0x02;
1093   2      //      }
1094   2      //        SBUF=0x19;while(!(SCON&0x02));SCON &=~0x02; _nop_();
1095   2            Delay_ms(500);
1096   2                if( Uart4FindCartACK[6] == 0x04){//¶Á¿¨Ê§°Ü
1097   3                  UserCardReadState = STATE_NOCARD;
1098   3                  Flag_FindCard_500msOver=0;
1099   3              
1100   3      //            SBUF=0x20;while(!(SCON&0x02));SCON &=~0x02; 
1101   3      //            SBUF=0x59;while(!(SCON&0x02));SCON &=~0x02;
1102   3          //    SBUF=Uart4ACKCounter>>8;while(!(SCON&0x02));SCON &=~0x02; _nop_();
1103   3          //    SBUF=Uart4ACKCounter;while(!(SCON&0x02));SCON &=~0x02;  _nop_();
1104   3      //        for(i=0;i<Uart4ACKCounter;i++){
1105   3      //          SBUF=Uart4FindCartACK[i];
1106   3      //          while(!(SCON&0x02));
1107   3      //          SCON &=~0x02;
1108   3      //          _nop_();
1109   3      //        }
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 20  

1110   3            }else if(Uart4FindCartACK[6] == 0x08){//¶Á¿¨³É¹¦
1111   3              
1112   3      //        SBUF=0x05;while(!(SCON&0x02));SCON &=~0x02;
1113   3              for(j=0,i=136;j<18,i<172;j++,i+=2){
1114   4              IdNumberAscii[j]=Uart4FindCartACK[i];
1115   4            }
1116   3                for(i=0;i<8;i++){
1117   4                 Id_BCD_Buffer[i] = (IdNumberAscii[i*2]-0x30)<<4;
1118   4                 Id_BCD_Buffer[i] |= (IdNumberAscii[i*2+1]-0x30);
1119   4                }
1120   3              if(IdNumberAscii[17] == 0x58){//Ä©Î²ÎªXµ¥¶À´¦Àí×ª»¯ÎªBCD 1010¼´Ê®½øÖÆ10  Ê®Áù½øÖÆÎª0x0a
1121   4              Id_BCD_Buffer[8]  = (IdNumberAscii[16] - 0x30)<<4;
1122   4              Id_BCD_Buffer[8] |= 0x0a;
1123   4            }else{
1124   4              Id_BCD_Buffer[8]  = (IdNumberAscii[16] - 0x30)<<4;
1125   4              Id_BCD_Buffer[8] |= (IdNumberAscii[17] - 0x30);
1126   4            }
1127   3            
1128   3      //      for(j=0;j<9;j++){
1129   3      //      SBUF=Id_BCD_Buffer[j];while(!(SCON&0x02));SCON &=~0x02;
1130   3      //      }
1131   3            Muti_Send_Byte(CommonDataBuffer,Fe_data_Organize(CMD_UploadUerID,Id_BCD_Buffer,9,0));//Á÷Ë®¹¦ÄÜÉÏ´«Éí·İ
             -Ö¤
1132   3            if(Search_IdOrErWeiMa_Info(Id_BCD_Buffer,1)!=0){
1133   4              DoorTrigger = 1;
1134   4              Buzzer_Beep(BuzzerTimeNormal);
1135   4            }else {   
1136   4            Muti_Send_Byte(CommonDataBuffer,Fe_data_Organize(CMD_SearchUerID,Id_BCD_Buffer,9,1));//·¢¸øÏÂ°åËÑË÷ÓÎ¿Í
             -ĞÅÏ¢
1137   4            }
1138   3      
1139   3                  UserCardReadState = STATE_NOCARD;
1140   3                  Flag_FindCard_500msOver=0;
1141   3          }
1142   2          
1143   2          }
1144   1      //  SBUF=0x39;while(!(SCON&0x02));SCON &=~0x02; _nop_();
1145   1        Uart4ACKCounter = 0;
1146   1      }
1147          
1148          
1149          
1150          
1151          
1152          
1153          
1154          
1155          
1156          
1157          
1158          /***********************************************
1159          º¯ÊıÃû³Æ£ºOp_Finger_Module
1160          º¯Êı¹¦ÄÜ£ºÂÖÑ¯Ö¸ÎÆÄ£¿éÊµÏÖÍÑ»úÈÏÖ¤
1161          Èë¿Úº¯Êı£ºÎŞ
1162          ³öºó¿ÚÊı£ºÎŞ
1163          ***********************************************/
1164          void Poll_Finger_Module(void){
1165   1      unsigned char cnt = 0;
1166   1      bit State = 0;
1167   1      unsigned char FingerStoreNumber[2]={0};
1168   1      unsigned char TempFingerId[4]={0};
1169   1      //  P41 = 1;
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 21  

1170   1        if(!LD9900MT_TOUCH_O)
1171   1      {
1172   2        
1173   2      if( LD9900MT_GetImage(550) != 0x00 & cnt < 1 )
1174   2      {                     //Ò»Ö±µÈ´ı»ñÈ¡Ö¸ÎÆÍ¼Ïñ³É¹¦
1175   3        State = 0;                                      //ÖÃ×´Ì¬Î»Îª0
1176   3        cnt++;      
1177   3      }
1178   2      if(cnt < 1)
1179   2        {
1180   3      //    SBUF = 0x08;while(!(SCON&0x02));SCON &= ~0x02;
1181   3        if(LD9900MT_GenChar(0x01,550) == 0x00)                      //Éú³ÉÌØÕ÷´¢´æÔÚ CharBuffer 1
1182   3          State = 1;
1183   3        else
1184   3          State = 0;
1185   3      }
1186   2      else
1187   2        {
1188   3        State = 0;
1189   3      }
1190   2      cnt = 0;
1191   2      if(State == 1)
1192   2      {
1193   3      //  SBUF = 0x09;while(!(SCON&0x02));SCON &= ~0x02;
1194   3      if(LD9900MT_Search(0x01,0x0000,1000,FingerStoreNumber) == 0x00){
1195   4        ShieldOpenOrClose=1;/*ÆÁ±ÎÇ¿ÖÆ¿ªÕ¢£¬±ÜÃâ¶ş´Î¿ªÕ¢*/
1196   4        //Search_IdOrErWeiMa_Info(FingerStoreNumber,0x03)+6
1197   4        //FLASH_W25Q64_Read(TempFingerId,SearchFingerStoreNumber(FingerStoreNumber),4);
1198   4        //Muti_Send_Byte(CommonDataBuffer,Fe_data_Organize(CMD_FingerUploadStreamInfo,&TempFingerId,4,0));//Á÷Ë®¹
             -¦ÄÜÖ¸ÎÆ ´Ë¾ä±ØĞë·ÅÔÚ·äÃùÆ÷Ç°Ãæ£¬·ñÔò³ö´í
1199   4        DoorTrigger = 1;
1200   4        LD9900MT_UpChar(0x01);        
1201   4        LD9900MT_UpCharDataProc(CMD_FingerUploadStreamInfo);
1202   4        Delay_ms(200);
1203   4        Buzzer_Beep(BuzzerTimeNormal);
1204   4        
1205   4      }
1206   3      }
1207   2      else  ;
1208   2      //SBUF = 0x10;while(!(SCON&0x02));SCON &= ~0x02;
1209   2      //P41 = 0;
1210   2      }
1211   1      }
1212          
1213          unsigned long int  SearchFingerStoreNumber(unsigned char FingerStoreNumber[]){
1214   1      unsigned long int i = 0;
1215   1      unsigned char j = 0;
1216   1      unsigned char TempBuffer[2]={0};
1217   1      for(j=0;j<16;j++){
1218   2          for(i=FingerId_AddrTable[j][0]+30;i<FingerId_AddrTable[j][1];i+=10){
1219   3            FLASH_W25Q64_Read(TempBuffer,i+6,2);//¶ÁÈë»º³åÇø
1220   3            if( TempBuffer[0]!=0xff && TempBuffer[1]!=0xff)
1221   3              {
1222   4              if(FingerStoreNumber[0]==TempBuffer[0] && FingerStoreNumber[1]==TempBuffer[1] )
1223   4                {
1224   5                return i;
1225   5                  }else{          
1226   5                  break;          
1227   5                  }
1228   4            }else
1229   3              {
1230   4                break;
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 22  

1231   4              }
1232   3          }
1233   2      }
1234   1      return 0;
1235   1      }
1236          
1237          
1238          void Uart2_DATA_deal(void)
1239            {
1240   1        unsigned char CS = 0;
1241   1        unsigned int i;
1242   1        unsigned char ErWeiMaBCDBuffer[6] = {0};
1243   1        /*´¦ÀíÊı¾İ½ÓÊÕµ½µÄ¼ÓÃÜ¶şÎ¬ÂëÊı¾İ£¬Àı¼ÓÃÜÊı¾İÎª£ºeaf2c850402470500c1aa8*/
1244   1        //EWMBuffer1[0]='e';EWMBuffer1[1]='a';EWMBuffer1[2]='f';EWMBuffer1[3]='2';EWMBuffer1[4]='c';EWMBuffer1[5]
             -='8';
1245   1        //EWMBuffer1[6]='5';EWMBuffer1[7]='0';EWMBuffer1[8]='4';EWMBuffer1[9]='0';EWMBuffer1[10]='2';EWMBuffer1[1
             -1]='4';
1246   1        //EWMBuffer1[12]='7';EWMBuffer1[13]='0';EWMBuffer1[14]='5';EWMBuffer1[15]='0';EWMBuffer1[16]='0';EWMBuffe
             -r1[17]='c';
1247   1        //EWMBuffer1[18]='1';EWMBuffer1[19]='a';EWMBuffer1[20]='a';EWMBuffer1[21]='8';
1248   1        for(i=0;i<22;i++)/*½«½ÓÊÕµ½µÄÊı¾İ×ª»»ÎªÊ®Áù½øÖÆÊı¾İ*/
1249   1          {SBUF=EWMBuffer1[i];while(!(SCON&0X02));SCON &=~0X02;
1250   2           if(EWMBuffer1[i]>0x60) {EWMBuffer1[i]= EWMBuffer1[i]-0x57;}
1251   2           else {EWMBuffer1[i]= EWMBuffer1[i]-0x30;}
1252   2            }
1253   1        for(i=0;i<11;i++)/*ºÏ³ÉÊı¾İ²¢½âÃÜ*/
1254   1          {EWMBuffer[i]= EWMBuffer1[2*i]*16+EWMBuffer1[2*i+1];/*½«´¦Àí¹ıµÄÊı¾İºÏ³ÉÊ®Áù½øÖÆÊı¾İ*/
1255   2           EWMBuffer[i]=EWMBuffer[i]^EWMBuffer_Mima[i];}/*½âÃÜÊı¾İ*/
1256   1        for(i=0;i<11;i++) CS+=EWMBuffer[i];
1257   1      
1258   1      //º¯Êı¹¦ÄÜ:¶ÔÊı×é½øĞĞÆ´½Ó
1259   1      //Èë¿Úº¯Êı: Data_Dest     Ô­Êı×é
1260   1      //         Data_Src       ÒªÌí¼ÓµÄÊı×é
1261   1      //         DestDataNum    Ô­Êı×éµÄÊıÁ¿
1262   1      //         SrcDataNum     ÒªÌí¼ÓµÄÊıÁ¿
1263   1      //³ö¿Úº¯Êı:ÎŞ
1264   1          CS &=0x0F;
1265   1          Arraycat(EWMBuffer,&CS,11,1);
1266   1        for(i=0;i<11;i++)
1267   1        {SBUF = EWMBuffer[i];while(!(SCON&0x02));SCON &= ~0x02;}
1268   1        for(i=0;i<5;i++)
1269   1        {ErWeiMaBCDBuffer[i] = (EWMBuffer[i*2]-0x30)<<4;
1270   2           ErWeiMaBCDBuffer[i] |= (EWMBuffer[i*2+1]-0x30);}
1271   1        ErWeiMaBCDBuffer[5] = CS;
1272   1        ErWeiMaBCDBuffer[5] |= (EWMBuffer[10]-0x30)<<4;
1273   1      
1274   1      
1275   1      //      for(i=0;i<6;i++){
1276   1      //   SBUF = ErWeiMaBCDBuffer[i];while(!(SCON&0x02));SCON &= ~0x02;
1277   1      //  }
1278   1        Muti_Send_Byte(CommonDataBuffer,Fe_data_Organize(CMD_UploadErWeiMa,ErWeiMaBCDBuffer,6,0));//Á÷Ë®¹¦ÄÜÉÏ´«¶
             -şÎ¬Âë
1279   1        if(Search_IdOrErWeiMa_Info(ErWeiMaBCDBuffer,0) != 0){
1280   2                DoorTrigger = 1;
1281   2                Buzzer_Beep(BuzzerTimeNormal);
1282   2        }else {   
1283   2        Muti_Send_Byte(CommonDataBuffer,Fe_data_Organize(CMD_SearchErWerMa,ErWeiMaBCDBuffer,6,1));//·¢¸øÏÂ°åËÑË÷Ó
             -Î¿ÍĞÅÏ¢
1284   2        }
1285   1                  EWMCounter = 0;Flag_ErWeiMaReceiveStart=0;
1286   1      }
1287          
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 23  

1288          
1289          /***********************************************
1290          º¯ÊıÃû³Æ£ºUart3_DATA_deal
1291          º¯Êı¹¦ÄÜ£ºÀ¶ÑÀÉèÖÃ´¦Àíº¯Êı
1292          Èë¿Úº¯Êı£ºÎŞ
1293          ³öºó¿ÚÊı£ºÎŞ
1294          ***********************************************/
1295          
1296          void Uart3_DATA_deal(void){
1297   1      unsigned char DatBuffer = 0x00;
1298   1        Delay_ms(10);
1299   1        
1300   1       if((CMD_nReloadWifi[0] ==  BluetoothRecBuffer[0]) && (CMD_nReloadWifi[1] ==  BluetoothRecBuffer[1])){
1301   2        Muti_Send_Byte(CommonDataBuffer,Fe_data_Organize(CMD_nReloadWifi,&DatBuffer,1,1));
1302   2       }
1303   1      else if((CMD_SetSystemId[0] ==  BluetoothRecBuffer[0]) && (CMD_SetSystemId[1] ==  BluetoothRecBuffer[1]))
1304   1          { 
1305   2            FLASH_W25Q64_Update (System_SetParaAddr, &BluetoothRecBuffer[2], sizeof(System_ID));//¸üĞÂÏµÍ³IDĞÅÏ¢
1306   2            Delay_ms(500);
1307   2            Muti_Send_Byte(CommonDataBuffer,Fe_data_Organize(CMD_SetSystemId, &BluetoothRecBuffer[2],6,1));
1308   2            Delay_ms(2000);
1309   2            Muti_Send_Byte(CommonDataBuffer,Fe_data_Organize(CMD_ReStart,&DatBuffer,1,1));
1310   2            IAP_CONTR = 0x20;
1311   2          }
1312   1      else if((CMD_SetDoorOpenTime[0] ==  BluetoothRecBuffer[0]) && (CMD_SetDoorOpenTime[1] ==  BluetoothRecBuff
             -er[1]))
1313   1          { 
1314   2            FLASH_W25Q64_Update (System_SetParaAddr+10, &BluetoothRecBuffer[2], 2);//¸üĞÂÏµÍ³¿ªÃÅÊ±¼ä
1315   2            Buzzer_Beep(BuzzerTimeNormal);
1316   2            Reply_State(CMD_SetDoorOpenTime,1);
1317   2            Delay_ms(1000);
1318   2            IAP_CONTR = 0x20;
1319   2          }
1320   1      else if((CMD_DeleteSystem_SetPara[0] ==  BluetoothRecBuffer[0]) && (CMD_DeleteSystem_SetPara[1] ==  Blueto
             -othRecBuffer[1]))
1321   1          { 
1322   2            FLASH_W25Q64_PageErase(System_SetParaAddr);
1323   2            Buzzer_Beep(BuzzerTimeNormal);
1324   2            Reply_State(CMD_DeleteSystem_SetPara,1);
1325   2            Delay_ms(1000);
1326   2            IAP_CONTR = 0x20;
1327   2          }
1328   1      BTCounter  = 0;
1329   1      memset(BluetoothRecBuffer,0x00,30);
1330   1      }
1331          
1332          
1333          
1334          /*****************************************************************************/
1335          /*´®¿ÚÊı¾İ·¢ËÍ³ÌĞò                               */
1336          /*Èë¿Ú²ÎÊı£ºdata ´ı·¢ËÍµÄÊı¾İ»º´æ                                            */
1337          /*          len ´ı·¢ËÍÊı¾İµÄ¸öÊı                                             */
1338          /*          UATR_Num   Ê¹ÓÃµÄ´®¿ÚºÅ                                          */
1339          /*   ·µ»ØÖµ£º ÎŞ                                                             */
1340          /*****************************************************************************/
1341          void USART1_Send(unsigned char *dat,unsigned int len)
1342          {  unsigned int i;
1343   1      
1344   1      for(i=0;i<len;i++)  
1345   1      { 
1346   2        {SBUF=*dat++;while(!(SCON&0x02));SCON &=~0x02;_nop_();_nop_();}
1347   2      }
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 24  

1348   1      
1349   1      }
1350          
1351          void USART4_Send(unsigned char *dat,unsigned int len){
1352   1      unsigned int i;
1353   1      for(i=0;i<len;i++)  
1354   1      { 
1355   2       {S4BUF=*dat++;while(!(S4CON&0X02));S4CON &=~0X02;_nop_();_nop_();}   
1356   2      }
1357   1      
1358   1      }
1359          
1360          
1361          /*******************************************************
1362          º¯ÊıÃû³Æ£ºMuti_Send_Byte
1363          º¯Êı¹¦ÄÜ£º½ÓÊÕ1¸ö×Ö½ÚµÄÊı¾İ£©
1364          Èë¿Úº¯Êı£º
1365          ³ö¿Úº¯Êı£ºÊÕµ½µÄ×Ö·û
1366          ********************************************************/
1367          char Muti_Read_Byte(void)
1368          {  
1369   1      unsigned char dat;
1370   1        
1371   1      dat = P2;
1372   1      
1373   1      P1M1 &= ~(1<<2);                  //CHACK³õÊ¼»¯ÎªÊä³ö 
1374   1      P1M0 |= (1<<2);
1375   1      CHACK = 1;
1376   1      _nop_();
1377   1      CHACK = 0;
1378   1      return dat;
1379   1      } 
1380          
1381          
1382          /*******************************************************
1383          º¯ÊıÃû³Æ£ºMuti_Send_Byte
1384          º¯Êı¹¦ÄÜ£º±¾»úÖ÷¶¯¿ªÊ¼Ò»´Î»á»°£¨·¢ËÍÊı¾İ£©
1385          Èë¿Úº¯Êı£ºÒª×ªËÍµÄÊı¾İData  Êı¾İ³¤¶Èlen
1386          ³ö¿Úº¯Êı£ºÎŞ
1387          ********************************************************/
1388          void Muti_Send_Byte(unsigned char *Data,unsigned int len)
1389          { 
1390   1      unsigned int i=0; 
1391   1      //SBUF=0xbb;while(!(SCON&0X02));SCON &=~0X02;    
1392   1      
1393   1      if(!CHKREQ)
1394   1      {
1395   2      REQ = 1;                              //ÖÃREQÎªÓĞĞ§
1396   2      if(!CHKREQ)
1397   2      {
1398   3        P2M1 = 0x00;                        //P2ÎªÊä³ö
1399   3        P2M0 = 0xff;
1400   3        P1M1 |= (1<<2);
1401   3        P1M0 &= ~(1<<2);                    //CHACK³õÊ¼»¯ÎªÊäÈë
1402   3        while(i<len)
1403   3          {
1404   4            Delay_us(100);      
1405   4            P2 = *(Data+i);                 //½«Êı¾İËÍµ½P2¶Ë¿Ú
1406   4            Delay_us(10);
1407   4            STB = ~STB;
1408   4            while(CHACK);
1409   4            i++;
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 25  

1410   4          }
1411   3      REQ = 0;    
1412   3      }else REQ = 0;
1413   2      }
1414   1      REQ = 0;
1415   1      P2M1 = 0xff;
1416   1      P2M0 = 0x00;    //³õÊ¼»¯P2ÎªÊäÈë
1417   1      }
1418          
1419          /********************************************************
1420          º¯ÊıÃû³Æ:Arraycat
1421          º¯Êı¹¦ÄÜ:¶ÔÊı×é½øĞĞÆ´½Ó
1422          Èë¿Úº¯Êı: Data_Dest     Ô­Êı×é
1423                   Data_Src       ÒªÌí¼ÓµÄÊı×é
1424                   DestDataNum    Ô­Êı×éµÄÊıÁ¿
1425                   SrcDataNum     ÒªÌí¼ÓµÄÊıÁ¿
1426          ³ö¿Úº¯Êı:ÎŞ
1427          ±¸×¢:ÎŞ
1428          ********************************************************/
1429          void Arraycat(unsigned char *Data_Dest,unsigned char *Data_Src,unsigned int DestDataNum,unsigned int SrcDa
             -taNum)
1430           {unsigned int i;
1431   1        for(i=0;i<SrcDataNum;i++)
1432   1         {*(Data_Dest+DestDataNum+i)=*(Data_Src+i);} 
1433   1        }
1434          /*****************************************************************************
1435          ´®¿ÚÊı¾İÖ¡×éÖ¯³ÌĞò 
1436          º¯ÊıÃû³Æ:Fe_data_Organize
1437          Èë¿Ú²ÎÊı£º  CMD µ±Ç°²Ù×÷µÄÃüÁî                                                      
1438                    Data µ±Ç°µÄ²Ù×÷Êı¾İ                                       
1439                    DataNum   µ±Ç°µÄ²Ù×÷Êı¾İµÄ¸öÊı                                               
1440          ·µ»ØÖµ£º ÕûĞÍ£¬Îªµ±Ç°UART1_RE_DATAÊı×éÓĞĞ§Êı¾İµÄ¸öÊı                  
1441          ±¸×¢:³ÌĞò×éÖ¯³ÉÍ¨ÓÃ³ÌĞò£¬Ö»ÓÃ´«µİÏà¹ØµÄ²ÎÊı£¬×Ô¼ººÏ³É·µ»ØÖ¡£¬¶¨Òå½á¹¹Ìå±äÁ¿¡£ 
1442            Ö¡½á¹¹Îª Ö¡Í· Êı¾İ³¤¶È Ä¿±êµØÖ· ĞòÁĞºÅ ÃüÁî Êı¾İ Ğ£ÑéºÍ Ö¡Î²            
1443          *****************************************************************************/
1444          unsigned int Fe_data_Organize(unsigned char CMD[],unsigned char Data[],unsigned int DataNum,bit OrgType)
1445           { 
1446   1        unsigned char Organize_DataBuffer[2]={0};
1447   1        unsigned int i=0;
1448   1        unsigned int StartPointer0=0,StartPointer1=0; 
1449   1        /************************************************************************/
1450   1        /*×éÖ¯Ö¡*/
1451   1        /*×éÖ¯Ö¡Í·*/
1452   1          if(OrgType){
1453   2        StartPointer1=2;
1454   2        Arraycat(&CommonDataBuffer[0],&FE_START[0],StartPointer0,StartPointer1);/*×éÖ¯Ö¡Í·*/
1455   2        }else if(!OrgType){
1456   2        StartPointer1=2;
1457   2        Arraycat(&CommonDataBuffer[0],&FE_START_ACK[0],StartPointer0,StartPointer1);/*×éÖ¯Ö¡Í·*/
1458   2        }
1459   1        StartPointer0=StartPointer0+StartPointer1;
1460   1        Organize_DataBuffer[0]=(DataNum&0xff00)>>8;/*×·¼ÓÊı¾İ³¤¶È*/
1461   1        Organize_DataBuffer[1]=DataNum&0xff;
1462   1        StartPointer1=2;
1463   1        Arraycat(&CommonDataBuffer[0],&Organize_DataBuffer[0],StartPointer0,StartPointer1);
1464   1        StartPointer0=StartPointer0+StartPointer1;
1465   1        StartPointer1=6;
1466   1        Arraycat(&CommonDataBuffer[0],&System_ID[0],StartPointer0,StartPointer1);/*×·¼ÓÖ÷»úID*/
1467   1        StartPointer0=StartPointer0+StartPointer1;
1468   1        CommonDataBuffer[StartPointer0]=UART_Fe_Seq;
1469   1        StartPointer0++;
1470   1        StartPointer1=2;
C51 COMPILER V9.54   UTILSFUNCTION                                                         06/16/2016 19:33:40 PAGE 26  

1471   1        Arraycat(&CommonDataBuffer[0],&CMD[0],StartPointer0,StartPointer1);/*×·¼ÓÃüÁîºÅ*/
1472   1        StartPointer0=StartPointer0+StartPointer1;
1473   1        if(DataNum>0) 
1474   1         {StartPointer1=DataNum;
1475   2          Arraycat(&CommonDataBuffer[0],&Data[0],StartPointer0,StartPointer1);/*×·¼ÓÊı¾İ*/
1476   2          StartPointer0=StartPointer0+StartPointer1; }
1477   1         Organize_DataBuffer[0]=0;
1478   1        for(i=0;i<StartPointer0;i++)/*¼ÆËãĞ£ÑéºÍ*/
1479   1          Organize_DataBuffer[0]=Organize_DataBuffer[0]+CommonDataBuffer[i];
1480   1      //    S4BUF =StartPointer0>>8;while(!(S4CON&0x02));S4CON &=~0x02;_nop_();
1481   1      //    S4BUF =StartPointer0;while(!(S4CON&0x02));S4CON &=~0x02;_nop_();
1482   1      //    S4BUF =Organize_DataBuffer[0];while(!(S4CON&0x02));S4CON &=~0x02;_nop_();
1483   1          Organize_DataBuffer[1]=0x16;
1484   1          Arraycat(&CommonDataBuffer[0],&Organize_DataBuffer[0],StartPointer0,2);/*×·¼ÓĞ£ÑéºÍºÍÖ¡Î²*/
1485   1          StartPointer0=StartPointer0+2;
1486   1          return(StartPointer0);
1487   1      }
1488           
1489          
1490          void Delay_ms(UINT ms){
1491   1      UINT k;
1492   1      unsigned char i, j;
1493   1      for(k=0;k<ms;k++){
1494   2        _nop_();
1495   2        _nop_();
1496   2        i = 22;
1497   2        j = 128;
1498   2        do
1499   2        {
1500   3          while (--j);
1501   3        } while (--i);
1502   2      }
1503   1      
1504   1      }
1505          void Delay_us(UINT us){
1506   1      UINT k;
1507   1      unsigned char i;
1508   1      for(k=0;k<us;k++){
1509   2        i = 3;
1510   2        while (--i);
1511   2      }
1512   1      }
1513          
1514          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  12046    ----
   CONSTANT SIZE    =    599    ----
   XDATA SIZE       =   2709     293
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      7       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
